pragma solidity ^0.8.10;

/// @dev A library for validating signatures from ZeroEx
library Signatures {
  // '\x19Ethereum Signed Message:\n32\x00\x00\x00\x00'.
  uint256 private constant ETH_SIGN_HASH_PREFIX =
    0x19457468657265756d205369676e6564204d6573736167653a0a333200000000;

  /// @dev Allowed signature types.
  enum SignatureType {
    EIP712,
    ETHSIGN
  }

  /// @dev Encoded EC signature.
  struct Signature {
    // How to validate the signature.
    SignatureType signatureType;
    // EC Signature data.
    uint8 v;
    // EC Signature data.
    bytes32 r;
    // EC Signature data.
    bytes32 s;
  }

  /// @dev Retrieve the signer of a signature.
  ///      Throws if the signature can't be validated.
  /// @param hash The hash that was signed.
  /// @param signature The signature.
  /// @return recovered The recovered signer address.
  function getSignerOfHash(bytes32 hash, Signature memory signature)
    internal
    pure
    returns (address recovered)
  {
    if (signature.signatureType == SignatureType.EIP712) {
      // Signed using EIP712
      recovered = ecrecover(hash, signature.v, signature.r, signature.s);
    } else if (signature.signatureType == SignatureType.ETHSIGN) {
      // Signed using `eth_sign`
      // Need to hash `hash` with "\x19Ethereum Signed Message:\n32" prefix
      // in packed encoding.
      bytes32 ethSignHash;
      assembly {
        // Use scratch space
        mstore(0, ETH_SIGN_HASH_PREFIX) // length of 28 bytes
        mstore(28, hash) // length of 32 bytes
        ethSignHash := keccak256(0, 60)
      }
      recovered = ecrecover(ethSignHash, signature.v, signature.r, signature.s);
    }
    // `recovered` can be null if the signature values are out of range.
    require(recovered != address(0), "recovered address is null");
  }
}
