/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={268:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});var a=n(81),i=n.n(a),r=n(645),s=n.n(r)()(i());s.push([e.id,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);"]),s.push([e.id,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""]);const o=s},645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",a=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),a&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),a&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,a,i,r){"string"==typeof e&&(e=[[null,e,void 0]]);var s={};if(a)for(var o=0;o<this.length;o++){var l=this[o][0];null!=l&&(s[l]=!0)}for(var d=0;d<e.length;d++){var u=[].concat(e[d]);a&&s[u[0]]||(void 0!==r&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=r),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),i&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=i):u[4]="".concat(i)),t.push(u))}},t}},81:e=>{"use strict";e.exports=function(e){return e[1]}},387:(e,t,n)=>{var a=n(268);a.__esModule&&(a=a.default),"string"==typeof a&&(a=[[e.id,a,""]]),a.locals&&(e.exports=a.locals),(0,n(346).Z)("0b345cf4",a,!1,{})},346:(e,t,n)=>{"use strict";function a(e,t){for(var n=[],a={},i=0;i<t.length;i++){var r=t[i],s=r[0],o={id:e+":"+i,css:r[1],media:r[2],sourceMap:r[3]};a[s]?a[s].parts.push(o):n.push(a[s]={id:s,parts:[o]})}return n}n.d(t,{Z:()=>m});var i="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var r={},s=i&&(document.head||document.getElementsByTagName("head")[0]),o=null,l=0,d=!1,u=function(){},p=null,c="data-vue-ssr-id",y="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function m(e,t,n,i){d=n,p=i||{};var s=a(e,t);return f(s),function(t){for(var n=[],i=0;i<s.length;i++){var o=s[i];(l=r[o.id]).refs--,n.push(l)}for(t?f(s=a(e,t)):s=[],i=0;i<n.length;i++){var l;if(0===(l=n[i]).refs){for(var d=0;d<l.parts.length;d++)l.parts[d]();delete r[l.id]}}}}function f(e){for(var t=0;t<e.length;t++){var n=e[t],a=r[n.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](n.parts[i]);for(;i<n.parts.length;i++)a.parts.push(v(n.parts[i]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var s=[];for(i=0;i<n.parts.length;i++)s.push(v(n.parts[i]));r[n.id]={id:n.id,refs:1,parts:s}}}}function h(){var e=document.createElement("style");return e.type="text/css",s.appendChild(e),e}function v(e){var t,n,a=document.querySelector("style["+c+'~="'+e.id+'"]');if(a){if(d)return u;a.parentNode.removeChild(a)}if(y){var i=l++;a=o||(o=h()),t=T.bind(null,a,i,!1),n=T.bind(null,a,i,!0)}else a=h(),t=w.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var b,g=(b=[],function(e,t){return b[e]=t,b.filter(Boolean).join("\n")});function T(e,t,n,a){var i=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=g(t,i);else{var r=document.createTextNode(i),s=e.childNodes;s[t]&&e.removeChild(s[t]),s.length?e.insertBefore(r,s[t]):e.appendChild(r)}}function w(e,t){var n=t.css,a=t.media,i=t.sourceMap;if(a&&e.setAttribute("media",a),p.ssrId&&e.setAttribute(c,t.id),i&&(n+="\n/*# sourceURL="+i.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},t={};function n(a){var i=t[a];if(void 0!==i)return i.exports;var r=t[a]={id:a,exports:{}};return e[a](r,r.exports,n),r.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=Object.freeze({});function t(e){return null==e}function a(e){return null!=e}function i(e){return!0===e}function r(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function s(e){return null!==e&&"object"==typeof e}var o=Object.prototype.toString;function l(e){return"[object Object]"===o.call(e)}function d(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function u(e){return a(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function p(e){return null==e?"":Array.isArray(e)||l(e)&&e.toString===o?JSON.stringify(e,null,2):String(e)}function c(e){var t=parseFloat(e);return isNaN(t)?e:t}function y(e,t){for(var n=Object.create(null),a=e.split(","),i=0;i<a.length;i++)n[a[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var m=y("slot,component",!0),f=y("key,ref,slot,slot-scope,is");function h(e,t){if(e.length){var n=e.indexOf(t);if(n>-1)return e.splice(n,1)}}var v=Object.prototype.hasOwnProperty;function b(e,t){return v.call(e,t)}function g(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var T=/-(\w)/g,w=g((function(e){return e.replace(T,(function(e,t){return t?t.toUpperCase():""}))})),k=g((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),I=/\B([A-Z])/g,C=g((function(e){return e.replace(I,"-$1").toLowerCase()})),_=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function x(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function A(e,t){for(var n in t)e[n]=t[n];return e}function E(e){for(var t={},n=0;n<e.length;n++)e[n]&&A(t,e[n]);return t}function R(e,t,n){}var O=function(e,t,n){return!1},M=function(e){return e};function S(e,t){if(e===t)return!0;var n=s(e),a=s(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var i=Array.isArray(e),r=Array.isArray(t);if(i&&r)return e.length===t.length&&e.every((function(e,n){return S(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||r)return!1;var o=Object.keys(e),l=Object.keys(t);return o.length===l.length&&o.every((function(n){return S(e[n],t[n])}))}catch(e){return!1}}function P(e,t){for(var n=0;n<e.length;n++)if(S(e[n],t))return n;return-1}function $(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}var L="data-server-rendered",F=["component","directive","filter"],D=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],V={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:O,isReservedAttr:O,isUnknownElement:O,getTagNamespace:R,parsePlatformTagName:M,mustUseProp:O,async:!0,_lifecycleHooks:D},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function j(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function N(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var B,U=new RegExp("[^"+H.source+".$_\\d]"),z="__proto__"in{},q="undefined"!=typeof window,W="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,G=W&&WXEnvironment.platform.toLowerCase(),J=q&&window.navigator.userAgent.toLowerCase(),K=J&&/msie|trident/.test(J),Z=J&&J.indexOf("msie 9.0")>0,X=J&&J.indexOf("edge/")>0,Y=(J&&J.indexOf("android"),J&&/iphone|ipad|ipod|ios/.test(J)||"ios"===G),Q=(J&&/chrome\/\d+/.test(J),J&&/phantomjs/.test(J),J&&J.match(/firefox\/(\d+)/)),ee={}.watch,te=!1;if(q)try{var ne={};Object.defineProperty(ne,"passive",{get:function(){te=!0}}),window.addEventListener("test-passive",null,ne)}catch(e){}var ae=function(){return void 0===B&&(B=!q&&!W&&void 0!==n.g&&n.g.process&&"server"===n.g.process.env.VUE_ENV),B},ie=q&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function re(e){return"function"==typeof e&&/native code/.test(e.toString())}var se,oe="undefined"!=typeof Symbol&&re(Symbol)&&"undefined"!=typeof Reflect&&re(Reflect.ownKeys);se="undefined"!=typeof Set&&re(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var le=R,de=0,ue=function(){this.id=de++,this.subs=[]};ue.prototype.addSub=function(e){this.subs.push(e)},ue.prototype.removeSub=function(e){h(this.subs,e)},ue.prototype.depend=function(){ue.target&&ue.target.addDep(this)},ue.prototype.notify=function(){for(var e=this.subs.slice(),t=0,n=e.length;t<n;t++)e[t].update()},ue.target=null;var pe=[];function ce(e){pe.push(e),ue.target=e}function ye(){pe.pop(),ue.target=pe[pe.length-1]}var me=function(e,t,n,a,i,r,s,o){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=i,this.ns=void 0,this.context=r,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},fe={child:{configurable:!0}};fe.child.get=function(){return this.componentInstance},Object.defineProperties(me.prototype,fe);var he=function(e){void 0===e&&(e="");var t=new me;return t.text=e,t.isComment=!0,t};function ve(e){return new me(void 0,void 0,void 0,String(e))}function be(e){var t=new me(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var ge=Array.prototype,Te=Object.create(ge);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=ge[e];N(Te,e,(function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];var i,r=t.apply(this,n),s=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&s.observeArray(i),s.dep.notify(),r}))}));var we=Object.getOwnPropertyNames(Te),ke=!0;function Ie(e){ke=e}var Ce=function(e){this.value=e,this.dep=new ue,this.vmCount=0,N(e,"__ob__",this),Array.isArray(e)?(z?function(e,t){e.__proto__=t}(e,Te):function(e,t,n){for(var a=0,i=n.length;a<i;a++){var r=n[a];N(e,r,t[r])}}(e,Te,we),this.observeArray(e)):this.walk(e)};function _e(e,t){var n;if(s(e)&&!(e instanceof me))return b(e,"__ob__")&&e.__ob__ instanceof Ce?n=e.__ob__:ke&&!ae()&&(Array.isArray(e)||l(e))&&Object.isExtensible(e)&&!e._isVue&&(n=new Ce(e)),t&&n&&n.vmCount++,n}function xe(e,t,n,a,i){var r=new ue,s=Object.getOwnPropertyDescriptor(e,t);if(!s||!1!==s.configurable){var o=s&&s.get,l=s&&s.set;o&&!l||2!==arguments.length||(n=e[t]);var d=!i&&_e(n);Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var t=o?o.call(e):n;return ue.target&&(r.depend(),d&&(d.dep.depend(),Array.isArray(t)&&Re(t))),t},set:function(t){var a=o?o.call(e):n;t===a||t!=t&&a!=a||o&&!l||(l?l.call(e,t):n=t,d=!i&&_e(t),r.notify())}})}}function Ae(e,t,n){if(Array.isArray(e)&&d(t))return e.length=Math.max(e.length,t),e.splice(t,1,n),n;if(t in e&&!(t in Object.prototype))return e[t]=n,n;var a=e.__ob__;return e._isVue||a&&a.vmCount?n:a?(xe(a.value,t,n),a.dep.notify(),n):(e[t]=n,n)}function Ee(e,t){if(Array.isArray(e)&&d(t))e.splice(t,1);else{var n=e.__ob__;e._isVue||n&&n.vmCount||b(e,t)&&(delete e[t],n&&n.dep.notify())}}function Re(e){for(var t=void 0,n=0,a=e.length;n<a;n++)(t=e[n])&&t.__ob__&&t.__ob__.dep.depend(),Array.isArray(t)&&Re(t)}Ce.prototype.walk=function(e){for(var t=Object.keys(e),n=0;n<t.length;n++)xe(e,t[n])},Ce.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)_e(e[t])};var Oe=V.optionMergeStrategies;function Me(e,t){if(!t)return e;for(var n,a,i,r=oe?Reflect.ownKeys(t):Object.keys(t),s=0;s<r.length;s++)"__ob__"!==(n=r[s])&&(a=e[n],i=t[n],b(e,n)?a!==i&&l(a)&&l(i)&&Me(a,i):Ae(e,n,i));return e}function Se(e,t,n){return n?function(){var a="function"==typeof t?t.call(n,n):t,i="function"==typeof e?e.call(n,n):e;return a?Me(a,i):i}:t?e?function(){return Me("function"==typeof t?t.call(this,this):t,"function"==typeof e?e.call(this,this):e)}:t:e}function Pe(e,t){var n=t?e?e.concat(t):Array.isArray(t)?t:[t]:e;return n?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(n):n}function $e(e,t,n,a){var i=Object.create(e||null);return t?A(i,t):i}Oe.data=function(e,t,n){return n?Se(e,t,n):t&&"function"!=typeof t?e:Se(e,t)},D.forEach((function(e){Oe[e]=Pe})),F.forEach((function(e){Oe[e+"s"]=$e})),Oe.watch=function(e,t,n,a){if(e===ee&&(e=void 0),t===ee&&(t=void 0),!t)return Object.create(e||null);if(!e)return t;var i={};for(var r in A(i,e),t){var s=i[r],o=t[r];s&&!Array.isArray(s)&&(s=[s]),i[r]=s?s.concat(o):Array.isArray(o)?o:[o]}return i},Oe.props=Oe.methods=Oe.inject=Oe.computed=function(e,t,n,a){if(!e)return t;var i=Object.create(null);return A(i,e),t&&A(i,t),i},Oe.provide=Se;var Le=function(e,t){return void 0===t?e:t};function Fe(e,t,n){if("function"==typeof t&&(t=t.options),function(e,t){var n=e.props;if(n){var a,i,r={};if(Array.isArray(n))for(a=n.length;a--;)"string"==typeof(i=n[a])&&(r[w(i)]={type:null});else if(l(n))for(var s in n)i=n[s],r[w(s)]=l(i)?i:{type:i};e.props=r}}(t),function(e,t){var n=e.inject;if(n){var a=e.inject={};if(Array.isArray(n))for(var i=0;i<n.length;i++)a[n[i]]={from:n[i]};else if(l(n))for(var r in n){var s=n[r];a[r]=l(s)?A({from:r},s):{from:s}}}}(t),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];"function"==typeof a&&(t[n]={bind:a,update:a})}}(t),!t._base&&(t.extends&&(e=Fe(e,t.extends,n)),t.mixins))for(var a=0,i=t.mixins.length;a<i;a++)e=Fe(e,t.mixins[a],n);var r,s={};for(r in e)o(r);for(r in t)b(e,r)||o(r);function o(a){var i=Oe[a]||Le;s[a]=i(e[a],t[a],n,a)}return s}function De(e,t,n,a){if("string"==typeof n){var i=e[t];if(b(i,n))return i[n];var r=w(n);if(b(i,r))return i[r];var s=k(r);return b(i,s)?i[s]:i[n]||i[r]||i[s]}}function Ve(e,t,n,a){var i=t[e],r=!b(n,e),s=n[e],o=Be(Boolean,i.type);if(o>-1)if(r&&!b(i,"default"))s=!1;else if(""===s||s===C(e)){var l=Be(String,i.type);(l<0||o<l)&&(s=!0)}if(void 0===s){s=function(e,t,n){if(b(t,"default")){var a=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:"function"==typeof a&&"Function"!==je(t.type)?a.call(e):a}}(a,i,e);var d=ke;Ie(!0),_e(s),Ie(d)}return s}var He=/^\s*function (\w+)/;function je(e){var t=e&&e.toString().match(He);return t?t[1]:""}function Ne(e,t){return je(e)===je(t)}function Be(e,t){if(!Array.isArray(t))return Ne(t,e)?0:-1;for(var n=0,a=t.length;n<a;n++)if(Ne(t[n],e))return n;return-1}function Ue(e,t,n){ce();try{if(t)for(var a=t;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var r=0;r<i.length;r++)try{if(!1===i[r].call(a,e,t,n))return}catch(e){qe(e,a,"errorCaptured hook")}}qe(e,t,n)}finally{ye()}}function ze(e,t,n,a,i){var r;try{(r=n?e.apply(t,n):e.call(t))&&!r._isVue&&u(r)&&!r._handled&&(r.catch((function(e){return Ue(e,a,i+" (Promise/async)")})),r._handled=!0)}catch(e){Ue(e,a,i)}return r}function qe(e,t,n){if(V.errorHandler)try{return V.errorHandler.call(null,e,t,n)}catch(t){t!==e&&We(t)}We(e)}function We(e,t,n){if(!q&&!W||"undefined"==typeof console)throw e;console.error(e)}var Ge,Je=!1,Ke=[],Ze=!1;function Xe(){Ze=!1;var e=Ke.slice(0);Ke.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&re(Promise)){var Ye=Promise.resolve();Ge=function(){Ye.then(Xe),Y&&setTimeout(R)},Je=!0}else if(K||"undefined"==typeof MutationObserver||!re(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ge="undefined"!=typeof setImmediate&&re(setImmediate)?function(){setImmediate(Xe)}:function(){setTimeout(Xe,0)};else{var Qe=1,et=new MutationObserver(Xe),tt=document.createTextNode(String(Qe));et.observe(tt,{characterData:!0}),Ge=function(){Qe=(Qe+1)%2,tt.data=String(Qe)},Je=!0}function nt(e,t){var n;if(Ke.push((function(){if(e)try{e.call(t)}catch(e){Ue(e,t,"nextTick")}else n&&n(t)})),Ze||(Ze=!0,Ge()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}var at=new se;function it(e){rt(e,at),at.clear()}function rt(e,t){var n,a,i=Array.isArray(e);if(!(!i&&!s(e)||Object.isFrozen(e)||e instanceof me)){if(e.__ob__){var r=e.__ob__.dep.id;if(t.has(r))return;t.add(r)}if(i)for(n=e.length;n--;)rt(e[n],t);else for(n=(a=Object.keys(e)).length;n--;)rt(e[a[n]],t)}}var st=g((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function ot(e,t){function n(){var e=arguments,a=n.fns;if(!Array.isArray(a))return ze(a,null,arguments,t,"v-on handler");for(var i=a.slice(),r=0;r<i.length;r++)ze(i[r],null,e,t,"v-on handler")}return n.fns=e,n}function lt(e,n,a,r,s,o){var l,d,u,p;for(l in e)d=e[l],u=n[l],p=st(l),t(d)||(t(u)?(t(d.fns)&&(d=e[l]=ot(d,o)),i(p.once)&&(d=e[l]=s(p.name,d,p.capture)),a(p.name,d,p.capture,p.passive,p.params)):d!==u&&(u.fns=d,e[l]=u));for(l in n)t(e[l])&&r((p=st(l)).name,n[l],p.capture)}function dt(e,n,r){var s;e instanceof me&&(e=e.data.hook||(e.data.hook={}));var o=e[n];function l(){r.apply(this,arguments),h(s.fns,l)}t(o)?s=ot([l]):a(o.fns)&&i(o.merged)?(s=o).fns.push(l):s=ot([o,l]),s.merged=!0,e[n]=s}function ut(e,t,n,i,r){if(a(t)){if(b(t,n))return e[n]=t[n],r||delete t[n],!0;if(b(t,i))return e[n]=t[i],r||delete t[i],!0}return!1}function pt(e){return r(e)?[ve(e)]:Array.isArray(e)?yt(e):void 0}function ct(e){return a(e)&&a(e.text)&&!1===e.isComment}function yt(e,n){var s,o,l,d,u=[];for(s=0;s<e.length;s++)t(o=e[s])||"boolean"==typeof o||(d=u[l=u.length-1],Array.isArray(o)?o.length>0&&(ct((o=yt(o,(n||"")+"_"+s))[0])&&ct(d)&&(u[l]=ve(d.text+o[0].text),o.shift()),u.push.apply(u,o)):r(o)?ct(d)?u[l]=ve(d.text+o):""!==o&&u.push(ve(o)):ct(o)&&ct(d)?u[l]=ve(d.text+o.text):(i(e._isVList)&&a(o.tag)&&t(o.key)&&a(n)&&(o.key="__vlist"+n+"_"+s+"__"),u.push(o)));return u}function mt(e,t){if(e){for(var n=Object.create(null),a=oe?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++){var r=a[i];if("__ob__"!==r){for(var s=e[r].from,o=t;o;){if(o._provided&&b(o._provided,s)){n[r]=o._provided[s];break}o=o.$parent}if(!o&&"default"in e[r]){var l=e[r].default;n[r]="function"==typeof l?l.call(t):l}}}return n}}function ft(e,t){if(!e||!e.length)return{};for(var n={},a=0,i=e.length;a<i;a++){var r=e[a],s=r.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,r.context!==t&&r.fnContext!==t||!s||null==s.slot)(n.default||(n.default=[])).push(r);else{var o=s.slot,l=n[o]||(n[o]=[]);"template"===r.tag?l.push.apply(l,r.children||[]):l.push(r)}}for(var d in n)n[d].every(ht)&&delete n[d];return n}function ht(e){return e.isComment&&!e.asyncFactory||" "===e.text}function vt(e){return e.isComment&&e.asyncFactory}function bt(t,n,a){var i,r=Object.keys(n).length>0,s=t?!!t.$stable:!r,o=t&&t.$key;if(t){if(t._normalized)return t._normalized;if(s&&a&&a!==e&&o===a.$key&&!r&&!a.$hasNormal)return a;for(var l in i={},t)t[l]&&"$"!==l[0]&&(i[l]=gt(n,l,t[l]))}else i={};for(var d in n)d in i||(i[d]=Tt(n,d));return t&&Object.isExtensible(t)&&(t._normalized=i),N(i,"$stable",s),N(i,"$key",o),N(i,"$hasNormal",r),i}function gt(e,t,n){var a=function(){var e=arguments.length?n.apply(null,arguments):n({}),t=(e=e&&"object"==typeof e&&!Array.isArray(e)?[e]:pt(e))&&e[0];return e&&(!t||1===e.length&&t.isComment&&!vt(t))?void 0:e};return n.proxy&&Object.defineProperty(e,t,{get:a,enumerable:!0,configurable:!0}),a}function Tt(e,t){return function(){return e[t]}}function wt(e,t){var n,i,r,o,l;if(Array.isArray(e)||"string"==typeof e)for(n=new Array(e.length),i=0,r=e.length;i<r;i++)n[i]=t(e[i],i);else if("number"==typeof e)for(n=new Array(e),i=0;i<e;i++)n[i]=t(i+1,i);else if(s(e))if(oe&&e[Symbol.iterator]){n=[];for(var d=e[Symbol.iterator](),u=d.next();!u.done;)n.push(t(u.value,n.length)),u=d.next()}else for(o=Object.keys(e),n=new Array(o.length),i=0,r=o.length;i<r;i++)l=o[i],n[i]=t(e[l],l,i);return a(n)||(n=[]),n._isVList=!0,n}function kt(e,t,n,a){var i,r=this.$scopedSlots[e];r?(n=n||{},a&&(n=A(A({},a),n)),i=r(n)||("function"==typeof t?t():t)):i=this.$slots[e]||("function"==typeof t?t():t);var s=n&&n.slot;return s?this.$createElement("template",{slot:s},i):i}function It(e){return De(this.$options,"filters",e)||M}function Ct(e,t){return Array.isArray(e)?-1===e.indexOf(t):e!==t}function _t(e,t,n,a,i){var r=V.keyCodes[t]||n;return i&&a&&!V.keyCodes[t]?Ct(i,a):r?Ct(r,e):a?C(a)!==t:void 0===e}function xt(e,t,n,a,i){if(n&&s(n)){var r;Array.isArray(n)&&(n=E(n));var o=function(s){if("class"===s||"style"===s||f(s))r=e;else{var o=e.attrs&&e.attrs.type;r=a||V.mustUseProp(t,o,s)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var l=w(s),d=C(s);l in r||d in r||(r[s]=n[s],i&&((e.on||(e.on={}))["update:"+s]=function(e){n[s]=e}))};for(var l in n)o(l)}return e}function At(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||Rt(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,null,this),"__static__"+e,!1),a}function Et(e,t,n){return Rt(e,"__once__"+t+(n?"_"+n:""),!0),e}function Rt(e,t,n){if(Array.isArray(e))for(var a=0;a<e.length;a++)e[a]&&"string"!=typeof e[a]&&Ot(e[a],t+"_"+a,n);else Ot(e,t,n)}function Ot(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function Mt(e,t){if(t&&l(t)){var n=e.on=e.on?A({},e.on):{};for(var a in t){var i=n[a],r=t[a];n[a]=i?[].concat(i,r):r}}return e}function St(e,t,n,a){t=t||{$stable:!n};for(var i=0;i<e.length;i++){var r=e[i];Array.isArray(r)?St(r,t,n):r&&(r.proxy&&(r.fn.proxy=!0),t[r.key]=r.fn)}return a&&(t.$key=a),t}function Pt(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function $t(e,t){return"string"==typeof e?t+e:e}function Lt(e){e._o=Et,e._n=c,e._s=p,e._l=wt,e._t=kt,e._q=S,e._i=P,e._m=At,e._f=It,e._k=_t,e._b=xt,e._v=ve,e._e=he,e._u=St,e._g=Mt,e._d=Pt,e._p=$t}function Ft(t,n,a,r,s){var o,l=this,d=s.options;b(r,"_uid")?(o=Object.create(r))._original=r:(o=r,r=r._original);var u=i(d._compiled),p=!u;this.data=t,this.props=n,this.children=a,this.parent=r,this.listeners=t.on||e,this.injections=mt(d.inject,r),this.slots=function(){return l.$slots||bt(t.scopedSlots,l.$slots=ft(a,r)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return bt(t.scopedSlots,this.slots())}}),u&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=bt(t.scopedSlots,this.$slots)),d._scopeId?this._c=function(e,t,n,a){var i=qt(o,e,t,n,a,p);return i&&!Array.isArray(i)&&(i.fnScopeId=d._scopeId,i.fnContext=r),i}:this._c=function(e,t,n,a){return qt(o,e,t,n,a,p)}}function Dt(e,t,n,a,i){var r=be(e);return r.fnContext=n,r.fnOptions=a,t.slot&&((r.data||(r.data={})).slot=t.slot),r}function Vt(e,t){for(var n in t)e[w(n)]=t[n]}Lt(Ft.prototype);var Ht={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;Ht.prepatch(n,n)}else(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},i=e.data.inlineTemplate;return a(i)&&(n.render=i.render,n.staticRenderFns=i.staticRenderFns),new e.componentOptions.Ctor(n)}(e,tn)).$mount(t?e.elm:void 0,t)},prepatch:function(t,n){var a=n.componentOptions;!function(t,n,a,i,r){var s=i.data.scopedSlots,o=t.$scopedSlots,l=!!(s&&!s.$stable||o!==e&&!o.$stable||s&&t.$scopedSlots.$key!==s.$key||!s&&t.$scopedSlots.$key),d=!!(r||t.$options._renderChildren||l);if(t.$options._parentVnode=i,t.$vnode=i,t._vnode&&(t._vnode.parent=i),t.$options._renderChildren=r,t.$attrs=i.data.attrs||e,t.$listeners=a||e,n&&t.$options.props){Ie(!1);for(var u=t._props,p=t.$options._propKeys||[],c=0;c<p.length;c++){var y=p[c],m=t.$options.props;u[y]=Ve(y,m,n,t)}Ie(!0),t.$options.propsData=n}a=a||e;var f=t.$options._parentListeners;t.$options._parentListeners=a,en(t,a,f),d&&(t.$slots=ft(r,i.context),t.$forceUpdate())}(n.componentInstance=t.componentInstance,a.propsData,a.listeners,n,a.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,on(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,dn.push(t)):rn(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?sn(t,!0):t.$destroy())}},jt=Object.keys(Ht);function Nt(n,r,o,l,d){if(!t(n)){var p=o.$options._base;if(s(n)&&(n=p.extend(n)),"function"==typeof n){var c;if(t(n.cid)&&(n=function(e,n){if(i(e.error)&&a(e.errorComp))return e.errorComp;if(a(e.resolved))return e.resolved;var r=Jt;if(r&&a(e.owners)&&-1===e.owners.indexOf(r)&&e.owners.push(r),i(e.loading)&&a(e.loadingComp))return e.loadingComp;if(r&&!a(e.owners)){var o=e.owners=[r],l=!0,d=null,p=null;r.$on("hook:destroyed",(function(){return h(o,r)}));var c=function(e){for(var t=0,n=o.length;t<n;t++)o[t].$forceUpdate();e&&(o.length=0,null!==d&&(clearTimeout(d),d=null),null!==p&&(clearTimeout(p),p=null))},y=$((function(t){e.resolved=Kt(t,n),l?o.length=0:c(!0)})),m=$((function(t){a(e.errorComp)&&(e.error=!0,c(!0))})),f=e(y,m);return s(f)&&(u(f)?t(e.resolved)&&f.then(y,m):u(f.component)&&(f.component.then(y,m),a(f.error)&&(e.errorComp=Kt(f.error,n)),a(f.loading)&&(e.loadingComp=Kt(f.loading,n),0===f.delay?e.loading=!0:d=setTimeout((function(){d=null,t(e.resolved)&&t(e.error)&&(e.loading=!0,c(!1))}),f.delay||200)),a(f.timeout)&&(p=setTimeout((function(){p=null,t(e.resolved)&&m(null)}),f.timeout)))),l=!1,e.loading?e.loadingComp:e.resolved}}(c=n,p),void 0===n))return function(e,t,n,a,i){var r=he();return r.asyncFactory=e,r.asyncMeta={data:t,context:n,children:a,tag:i},r}(c,r,o,l,d);r=r||{},En(n),a(r.model)&&function(e,t){var n=e.model&&e.model.prop||"value",i=e.model&&e.model.event||"input";(t.attrs||(t.attrs={}))[n]=t.model.value;var r=t.on||(t.on={}),s=r[i],o=t.model.callback;a(s)?(Array.isArray(s)?-1===s.indexOf(o):s!==o)&&(r[i]=[o].concat(s)):r[i]=o}(n.options,r);var y=function(e,n,i){var r=n.options.props;if(!t(r)){var s={},o=e.attrs,l=e.props;if(a(o)||a(l))for(var d in r){var u=C(d);ut(s,l,d,u,!0)||ut(s,o,d,u,!1)}return s}}(r,n);if(i(n.options.functional))return function(t,n,i,r,s){var o=t.options,l={},d=o.props;if(a(d))for(var u in d)l[u]=Ve(u,d,n||e);else a(i.attrs)&&Vt(l,i.attrs),a(i.props)&&Vt(l,i.props);var p=new Ft(i,l,s,r,t),c=o.render.call(null,p._c,p);if(c instanceof me)return Dt(c,i,p.parent,o);if(Array.isArray(c)){for(var y=pt(c)||[],m=new Array(y.length),f=0;f<y.length;f++)m[f]=Dt(y[f],i,p.parent,o);return m}}(n,y,r,o,l);var m=r.on;if(r.on=r.nativeOn,i(n.options.abstract)){var f=r.slot;r={},f&&(r.slot=f)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<jt.length;n++){var a=jt[n],i=t[a],r=Ht[a];i===r||i&&i._merged||(t[a]=i?Bt(r,i):r)}}(r);var v=n.options.name||d;return new me("vue-component-"+n.cid+(v?"-"+v:""),r,void 0,void 0,void 0,o,{Ctor:n,propsData:y,listeners:m,tag:d,children:l},c)}}}function Bt(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}var Ut=1,zt=2;function qt(e,t,n,o,l,d){return(Array.isArray(n)||r(n))&&(l=o,o=n,n=void 0),i(d)&&(l=zt),function(e,t,n,i,r){if(a(n)&&a(n.__ob__))return he();if(a(n)&&a(n.is)&&(t=n.is),!t)return he();var o,l,d;(Array.isArray(i)&&"function"==typeof i[0]&&((n=n||{}).scopedSlots={default:i[0]},i.length=0),r===zt?i=pt(i):r===Ut&&(i=function(e){for(var t=0;t<e.length;t++)if(Array.isArray(e[t]))return Array.prototype.concat.apply([],e);return e}(i)),"string"==typeof t)?(l=e.$vnode&&e.$vnode.ns||V.getTagNamespace(t),o=V.isReservedTag(t)?new me(V.parsePlatformTagName(t),n,i,void 0,void 0,e):n&&n.pre||!a(d=De(e.$options,"components",t))?new me(t,n,i,void 0,void 0,e):Nt(d,n,e,i,t)):o=Nt(t,n,e,i);return Array.isArray(o)?o:a(o)?(a(l)&&Wt(o,l),a(n)&&function(e){s(e.style)&&it(e.style),s(e.class)&&it(e.class)}(n),o):he()}(e,t,n,o,l)}function Wt(e,n,r){if(e.ns=n,"foreignObject"===e.tag&&(n=void 0,r=!0),a(e.children))for(var s=0,o=e.children.length;s<o;s++){var l=e.children[s];a(l.tag)&&(t(l.ns)||i(r)&&"svg"!==l.tag)&&Wt(l,n,r)}}var Gt,Jt=null;function Kt(e,t){return(e.__esModule||oe&&"Module"===e[Symbol.toStringTag])&&(e=e.default),s(e)?t.extend(e):e}function Zt(e){if(Array.isArray(e))for(var t=0;t<e.length;t++){var n=e[t];if(a(n)&&(a(n.componentOptions)||vt(n)))return n}}function Xt(e,t){Gt.$on(e,t)}function Yt(e,t){Gt.$off(e,t)}function Qt(e,t){var n=Gt;return function a(){null!==t.apply(null,arguments)&&n.$off(e,a)}}function en(e,t,n){Gt=e,lt(t,n||{},Xt,Yt,Qt,e),Gt=void 0}var tn=null;function nn(e){var t=tn;return tn=e,function(){tn=t}}function an(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function rn(e,t){if(t){if(e._directInactive=!1,an(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)rn(e.$children[n]);on(e,"activated")}}function sn(e,t){if(!(t&&(e._directInactive=!0,an(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)sn(e.$children[n]);on(e,"deactivated")}}function on(e,t){ce();var n=e.$options[t],a=t+" hook";if(n)for(var i=0,r=n.length;i<r;i++)ze(n[i],e,null,e,a);e._hasHookEvent&&e.$emit("hook:"+t),ye()}var ln=[],dn=[],un={},pn=!1,cn=!1,yn=0,mn=0,fn=Date.now;if(q&&!K){var hn=window.performance;hn&&"function"==typeof hn.now&&fn()>document.createEvent("Event").timeStamp&&(fn=function(){return hn.now()})}function vn(){var e,t;for(mn=fn(),cn=!0,ln.sort((function(e,t){return e.id-t.id})),yn=0;yn<ln.length;yn++)(e=ln[yn]).before&&e.before(),t=e.id,un[t]=null,e.run();var n=dn.slice(),a=ln.slice();yn=ln.length=dn.length=0,un={},pn=cn=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,rn(e[t],!0)}(n),function(e){for(var t=e.length;t--;){var n=e[t],a=n.vm;a._watcher===n&&a._isMounted&&!a._isDestroyed&&on(a,"updated")}}(a),ie&&V.devtools&&ie.emit("flush")}var bn=0,gn=function(e,t,n,a,i){this.vm=e,i&&(e._watcher=this),e._watchers.push(this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++bn,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new se,this.newDepIds=new se,this.expression="","function"==typeof t?this.getter=t:(this.getter=function(e){if(!U.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=R)),this.value=this.lazy?void 0:this.get()};gn.prototype.get=function(){var e;ce(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;Ue(e,t,'getter for watcher "'+this.expression+'"')}finally{this.deep&&it(e),ye(),this.cleanupDeps()}return e},gn.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},gn.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},gn.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==un[t]){if(un[t]=!0,cn){for(var n=ln.length-1;n>yn&&ln[n].id>e.id;)n--;ln.splice(n+1,0,e)}else ln.push(e);pn||(pn=!0,nt(vn))}}(this)},gn.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||s(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'+this.expression+'"';ze(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},gn.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},gn.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},gn.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||h(this.vm._watchers,this);for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1}};var Tn={enumerable:!0,configurable:!0,get:R,set:R};function wn(e,t,n){Tn.get=function(){return this[t][n]},Tn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,Tn)}var kn={lazy:!0};function In(e,t,n){var a=!ae();"function"==typeof n?(Tn.get=a?Cn(t):_n(n),Tn.set=R):(Tn.get=n.get?a&&!1!==n.cache?Cn(t):_n(n.get):R,Tn.set=n.set||R),Object.defineProperty(e,t,Tn)}function Cn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),ue.target&&t.depend(),t.value}}function _n(e){return function(){return e.call(this,this)}}function xn(e,t,n,a){return l(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}var An=0;function En(e){var t=e.options;if(e.super){var n=En(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var i in n)n[i]!==a[i]&&(t||(t={}),t[i]=n[i]);return t}(e);a&&A(e.extendOptions,a),(t=e.options=Fe(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function Rn(e){this._init(e)}function On(e){return e&&(e.Ctor.options.name||e.tag)}function Mn(e,t){return Array.isArray(e)?e.indexOf(t)>-1:"string"==typeof e?e.split(",").indexOf(t)>-1:(n=e,!("[object RegExp]"!==o.call(n))&&e.test(t));var n}function Sn(e,t){var n=e.cache,a=e.keys,i=e._vnode;for(var r in n){var s=n[r];if(s){var o=s.name;o&&!t(o)&&Pn(n,r,a,i)}}}function Pn(e,t,n,a){var i=e[t];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),e[t]=null,h(n,t)}!function(t){t.prototype._init=function(t){var n=this;n._uid=An++,n._isVue=!0,t&&t._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var i=a.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(n,t):n.$options=Fe(En(n.constructor),t||{},n),n._renderProxy=n,n._self=n,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&en(e,t)}(n),function(t){t._vnode=null,t._staticTrees=null;var n=t.$options,a=t.$vnode=n._parentVnode,i=a&&a.context;t.$slots=ft(n._renderChildren,i),t.$scopedSlots=e,t._c=function(e,n,a,i){return qt(t,e,n,a,i,!1)},t.$createElement=function(e,n,a,i){return qt(t,e,n,a,i,!0)};var r=a&&a.data;xe(t,"$attrs",r&&r.attrs||e,null,!0),xe(t,"$listeners",n._parentListeners||e,null,!0)}(n),on(n,"beforeCreate"),function(e){var t=mt(e.$options.inject,e);t&&(Ie(!1),Object.keys(t).forEach((function(n){xe(e,n,t[n])})),Ie(!0))}(n),function(e){e._watchers=[];var t=e.$options;t.props&&function(e,t){var n=e.$options.propsData||{},a=e._props={},i=e.$options._propKeys=[];!e.$parent||Ie(!1);var r=function(r){i.push(r);var s=Ve(r,t,n,e);xe(a,r,s),r in e||wn(e,"_props",r)};for(var s in t)r(s);Ie(!0)}(e,t.props),t.methods&&function(e,t){for(var n in e.$options.props,t)e[n]="function"!=typeof t[n]?R:_(t[n],e)}(e,t.methods),t.data?function(e){var t=e.$options.data;l(t=e._data="function"==typeof t?function(e,t){ce();try{return e.call(t,t)}catch(e){return Ue(e,t,"data()"),{}}finally{ye()}}(t,e):t||{})||(t={});for(var n=Object.keys(t),a=e.$options.props,i=(e.$options.methods,n.length);i--;){var r=n[i];a&&b(a,r)||j(r)||wn(e,"_data",r)}_e(t,!0)}(e):_e(e._data={},!0),t.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=ae();for(var i in t){var r=t[i],s="function"==typeof r?r:r.get;a||(n[i]=new gn(e,s||R,R,kn)),i in e||In(e,i,r)}}(e,t.computed),t.watch&&t.watch!==ee&&function(e,t){for(var n in t){var a=t[n];if(Array.isArray(a))for(var i=0;i<a.length;i++)xn(e,n,a[i]);else xn(e,n,a)}}(e,t.watch)}(n),function(e){var t=e.$options.provide;t&&(e._provided="function"==typeof t?t.call(e):t)}(n),on(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(Rn),function(e){Object.defineProperty(e.prototype,"$data",{get:function(){return this._data}}),Object.defineProperty(e.prototype,"$props",{get:function(){return this._props}}),e.prototype.$set=Ae,e.prototype.$delete=Ee,e.prototype.$watch=function(e,t,n){var a=this;if(l(t))return xn(a,e,t,n);(n=n||{}).user=!0;var i=new gn(a,e,t,n);if(n.immediate){var r='callback for immediate watcher "'+i.expression+'"';ce(),ze(t,a,[i.value],a,r),ye()}return function(){i.teardown()}}}(Rn),function(e){var t=/^hook:/;e.prototype.$on=function(e,n){var a=this;if(Array.isArray(e))for(var i=0,r=e.length;i<r;i++)a.$on(e[i],n);else(a._events[e]||(a._events[e]=[])).push(n),t.test(e)&&(a._hasHookEvent=!0);return a},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,t){var n=this;if(!arguments.length)return n._events=Object.create(null),n;if(Array.isArray(e)){for(var a=0,i=e.length;a<i;a++)n.$off(e[a],t);return n}var r,s=n._events[e];if(!s)return n;if(!t)return n._events[e]=null,n;for(var o=s.length;o--;)if((r=s[o])===t||r.fn===t){s.splice(o,1);break}return n},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?x(n):n;for(var a=x(arguments,1),i='event handler for "'+e+'"',r=0,s=n.length;r<s;r++)ze(n[r],t,a,t,i)}return t}}(Rn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,i=n._vnode,r=nn(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),r(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){on(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||h(t.$children,e),e._watcher&&e._watcher.teardown();for(var n=e._watchers.length;n--;)e._watchers[n].teardown();e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),on(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Rn),function(e){Lt(e.prototype),e.prototype.$nextTick=function(e){return nt(e,this)},e.prototype._render=function(){var e,t=this,n=t.$options,a=n.render,i=n._parentVnode;i&&(t.$scopedSlots=bt(i.data.scopedSlots,t.$slots,t.$scopedSlots)),t.$vnode=i;try{Jt=t,e=a.call(t._renderProxy,t.$createElement)}catch(n){Ue(n,t,"render"),e=t._vnode}finally{Jt=null}return Array.isArray(e)&&1===e.length&&(e=e[0]),e instanceof me||(e=he()),e.parent=i,e}}(Rn);var $n=[String,RegExp,Array],Ln={name:"keep-alive",abstract:!0,props:{include:$n,exclude:$n,max:[String,Number]},methods:{cacheVNode:function(){var e=this,t=e.cache,n=e.keys,a=e.vnodeToCache,i=e.keyToCache;if(a){var r=a.tag,s=a.componentInstance,o=a.componentOptions;t[i]={name:On(o),tag:r,componentInstance:s},n.push(i),this.max&&n.length>parseInt(this.max)&&Pn(t,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Pn(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){Sn(e,(function(e){return Mn(t,e)}))})),this.$watch("exclude",(function(t){Sn(e,(function(e){return!Mn(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=Zt(e),n=t&&t.componentOptions;if(n){var a=On(n),i=this.include,r=this.exclude;if(i&&(!a||!Mn(i,a))||r&&a&&Mn(r,a))return t;var s=this.cache,o=this.keys,l=null==t.key?n.Ctor.cid+(n.tag?"::"+n.tag:""):t.key;s[l]?(t.componentInstance=s[l].componentInstance,h(o,l),o.push(l)):(this.vnodeToCache=t,this.keyToCache=l),t.data.keepAlive=!0}return t||e&&e[0]}},Fn={KeepAlive:Ln};!function(e){var t={get:function(){return V}};Object.defineProperty(e,"config",t),e.util={warn:le,extend:A,mergeOptions:Fe,defineReactive:xe},e.set=Ae,e.delete=Ee,e.nextTick=nt,e.observable=function(e){return _e(e),e},e.options=Object.create(null),F.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,A(e.options.components,Fn),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=x(arguments,1);return n.unshift(this),"function"==typeof e.install?e.install.apply(e,n):"function"==typeof e&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=Fe(this.options,e),this}}(e),function(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,i=e._Ctor||(e._Ctor={});if(i[a])return i[a];var r=e.name||n.options.name,s=function(e){this._init(e)};return(s.prototype=Object.create(n.prototype)).constructor=s,s.cid=t++,s.options=Fe(n.options,e),s.super=n,s.options.props&&function(e){var t=e.options.props;for(var n in t)wn(e.prototype,"_props",n)}(s),s.options.computed&&function(e){var t=e.options.computed;for(var n in t)In(e.prototype,n,t[n])}(s),s.extend=n.extend,s.mixin=n.mixin,s.use=n.use,F.forEach((function(e){s[e]=n[e]})),r&&(s.options.components[r]=s),s.superOptions=n.options,s.extendOptions=e,s.sealedOptions=A({},s.options),i[a]=s,s}}(e),function(e){F.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&l(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&"function"==typeof n&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(Rn),Object.defineProperty(Rn.prototype,"$isServer",{get:ae}),Object.defineProperty(Rn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Rn,"FunctionalRenderContext",{value:Ft}),Rn.version="2.6.14";var Dn=y("style,class"),Vn=y("input,textarea,option,select,progress"),Hn=function(e,t,n){return"value"===n&&Vn(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},jn=y("contenteditable,draggable,spellcheck"),Nn=y("events,caret,typing,plaintext-only"),Bn=function(e,t){return Gn(t)||"false"===t?"false":"contenteditable"===e&&Nn(t)?t:"true"},Un=y("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),zn="http://www.w3.org/1999/xlink",qn=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},Wn=function(e){return qn(e)?e.slice(6,e.length):""},Gn=function(e){return null==e||!1===e};function Jn(e,t){return{staticClass:Kn(e.staticClass,t.staticClass),class:a(e.class)?[e.class,t.class]:t.class}}function Kn(e,t){return e?t?e+" "+t:e:t||""}function Zn(e){return Array.isArray(e)?function(e){for(var t,n="",i=0,r=e.length;i<r;i++)a(t=Zn(e[i]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):s(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var Xn={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Yn=y("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Qn=y("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),ea=function(e){return Yn(e)||Qn(e)};function ta(e){return Qn(e)?"svg":"math"===e?"math":void 0}var na=Object.create(null),aa=y("text,number,password,search,email,tel,url");function ia(e){return"string"==typeof e?document.querySelector(e)||document.createElement("div"):e}var ra=Object.freeze({createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(Xn[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),sa={create:function(e,t){oa(t)},update:function(e,t){e.data.ref!==t.data.ref&&(oa(e,!0),oa(t))},destroy:function(e){oa(e,!0)}};function oa(e,t){var n=e.data.ref;if(a(n)){var i=e.context,r=e.componentInstance||e.elm,s=i.$refs;t?Array.isArray(s[n])?h(s[n],r):s[n]===r&&(s[n]=void 0):e.data.refInFor?Array.isArray(s[n])?s[n].indexOf(r)<0&&s[n].push(r):s[n]=[r]:s[n]=r}}var la=new me("",{},[]),da=["create","activate","update","remove","destroy"];function ua(e,n){return e.key===n.key&&e.asyncFactory===n.asyncFactory&&(e.tag===n.tag&&e.isComment===n.isComment&&a(e.data)===a(n.data)&&function(e,t){if("input"!==e.tag)return!0;var n,i=a(n=e.data)&&a(n=n.attrs)&&n.type,r=a(n=t.data)&&a(n=n.attrs)&&n.type;return i===r||aa(i)&&aa(r)}(e,n)||i(e.isAsyncPlaceholder)&&t(n.asyncFactory.error))}function pa(e,t,n){var i,r,s={};for(i=t;i<=n;++i)a(r=e[i].key)&&(s[r]=i);return s}var ca={create:ya,update:ya,destroy:function(e){ya(e,la)}};function ya(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,i,r=e===la,s=t===la,o=fa(e.data.directives,e.context),l=fa(t.data.directives,t.context),d=[],u=[];for(n in l)a=o[n],i=l[n],a?(i.oldValue=a.value,i.oldArg=a.arg,va(i,"update",t,e),i.def&&i.def.componentUpdated&&u.push(i)):(va(i,"bind",t,e),i.def&&i.def.inserted&&d.push(i));if(d.length){var p=function(){for(var n=0;n<d.length;n++)va(d[n],"inserted",t,e)};r?dt(t,"insert",p):p()}if(u.length&&dt(t,"postpatch",(function(){for(var n=0;n<u.length;n++)va(u[n],"componentUpdated",t,e)})),!r)for(n in o)l[n]||va(o[n],"unbind",e,e,s)}(e,t)}var ma=Object.create(null);function fa(e,t){var n,a,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++)(a=e[n]).modifiers||(a.modifiers=ma),i[ha(a)]=a,a.def=De(t.$options,"directives",a.name);return i}function ha(e){return e.rawName||e.name+"."+Object.keys(e.modifiers||{}).join(".")}function va(e,t,n,a,i){var r=e.def&&e.def[t];if(r)try{r(n.elm,e,n,a,i)}catch(a){Ue(a,n.context,"directive "+e.name+" "+t+" hook")}}var ba=[sa,ca];function ga(e,n){var i=n.componentOptions;if(!(a(i)&&!1===i.Ctor.options.inheritAttrs||t(e.data.attrs)&&t(n.data.attrs))){var r,s,o=n.elm,l=e.data.attrs||{},d=n.data.attrs||{};for(r in a(d.__ob__)&&(d=n.data.attrs=A({},d)),d)s=d[r],l[r]!==s&&Ta(o,r,s,n.data.pre);for(r in(K||X)&&d.value!==l.value&&Ta(o,"value",d.value),l)t(d[r])&&(qn(r)?o.removeAttributeNS(zn,Wn(r)):jn(r)||o.removeAttribute(r))}}function Ta(e,t,n,a){a||e.tagName.indexOf("-")>-1?wa(e,t,n):Un(t)?Gn(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):jn(t)?e.setAttribute(t,Bn(t,n)):qn(t)?Gn(n)?e.removeAttributeNS(zn,Wn(t)):e.setAttributeNS(zn,t,n):wa(e,t,n)}function wa(e,t,n){if(Gn(n))e.removeAttribute(t);else{if(K&&!Z&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var ka={create:ga,update:ga};function Ia(e,n){var i=n.elm,r=n.data,s=e.data;if(!(t(r.staticClass)&&t(r.class)&&(t(s)||t(s.staticClass)&&t(s.class)))){var o=function(e){for(var t=e.data,n=e,i=e;a(i.componentInstance);)(i=i.componentInstance._vnode)&&i.data&&(t=Jn(i.data,t));for(;a(n=n.parent);)n&&n.data&&(t=Jn(t,n.data));return r=t.staticClass,s=t.class,a(r)||a(s)?Kn(r,Zn(s)):"";var r,s}(n),l=i._transitionClasses;a(l)&&(o=Kn(o,Zn(l))),o!==i._prevClass&&(i.setAttribute("class",o),i._prevClass=o)}}var Ca,_a,xa,Aa,Ea,Ra,Oa={create:Ia,update:Ia},Ma=/[\w).+\-_$\]]/;function Sa(e){var t,n,a,i,r,s=!1,o=!1,l=!1,d=!1,u=0,p=0,c=0,y=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),s)39===t&&92!==n&&(s=!1);else if(o)34===t&&92!==n&&(o=!1);else if(l)96===t&&92!==n&&(l=!1);else if(d)47===t&&92!==n&&(d=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||u||p||c){switch(t){case 34:o=!0;break;case 39:s=!0;break;case 96:l=!0;break;case 40:c++;break;case 41:c--;break;case 91:p++;break;case 93:p--;break;case 123:u++;break;case 125:u--}if(47===t){for(var m=a-1,f=void 0;m>=0&&" "===(f=e.charAt(m));m--);f&&Ma.test(f)||(d=!0)}}else void 0===i?(y=a+1,i=e.slice(0,a).trim()):h();function h(){(r||(r=[])).push(e.slice(y,a).trim()),y=a+1}if(void 0===i?i=e.slice(0,a).trim():0!==y&&h(),r)for(a=0;a<r.length;a++)i=Pa(i,r[a]);return i}function Pa(e,t){var n=t.indexOf("(");if(n<0)return'_f("'+t+'")('+e+")";var a=t.slice(0,n),i=t.slice(n+1);return'_f("'+a+'")('+e+(")"!==i?","+i:i)}function $a(e,t){console.error("[Vue compiler]: "+e)}function La(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function Fa(e,t,n,a,i){(e.props||(e.props=[])).push(qa({name:t,value:n,dynamic:i},a)),e.plain=!1}function Da(e,t,n,a,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(qa({name:t,value:n,dynamic:i},a)),e.plain=!1}function Va(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push(qa({name:t,value:n},a))}function Ha(e,t,n,a,i,r,s,o){(e.directives||(e.directives=[])).push(qa({name:t,rawName:n,value:a,arg:i,isDynamicArg:r,modifiers:s},o)),e.plain=!1}function ja(e,t,n){return n?"_p("+t+',"'+e+'")':e+t}function Na(t,n,a,i,r,s,o,l){var d;(i=i||e).right?l?n="("+n+")==='click'?'contextmenu':("+n+")":"click"===n&&(n="contextmenu",delete i.right):i.middle&&(l?n="("+n+")==='click'?'mouseup':("+n+")":"click"===n&&(n="mouseup")),i.capture&&(delete i.capture,n=ja("!",n,l)),i.once&&(delete i.once,n=ja("~",n,l)),i.passive&&(delete i.passive,n=ja("&",n,l)),i.native?(delete i.native,d=t.nativeEvents||(t.nativeEvents={})):d=t.events||(t.events={});var u=qa({value:a.trim(),dynamic:l},o);i!==e&&(u.modifiers=i);var p=d[n];Array.isArray(p)?r?p.unshift(u):p.push(u):d[n]=p?r?[u,p]:[p,u]:u,t.plain=!1}function Ba(e,t,n){var a=Ua(e,":"+t)||Ua(e,"v-bind:"+t);if(null!=a)return Sa(a);if(!1!==n){var i=Ua(e,t);if(null!=i)return JSON.stringify(i)}}function Ua(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var i=e.attrsList,r=0,s=i.length;r<s;r++)if(i[r].name===t){i.splice(r,1);break}return n&&delete e.attrsMap[t],a}function za(e,t){for(var n=e.attrsList,a=0,i=n.length;a<i;a++){var r=n[a];if(t.test(r.name))return n.splice(a,1),r}}function qa(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function Wa(e,t,n){var a=n||{},i=a.number,r="$$v";a.trim&&(r="(typeof $$v === 'string'? $$v.trim(): $$v)"),i&&(r="_n("+r+")");var s=Ga(t,r);e.model={value:"("+t+")",expression:JSON.stringify(t),callback:"function ($$v) {"+s+"}"}}function Ga(e,t){var n=function(e){if(e=e.trim(),Ca=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<Ca-1)return(Aa=e.lastIndexOf("."))>-1?{exp:e.slice(0,Aa),key:'"'+e.slice(Aa+1)+'"'}:{exp:e,key:null};for(_a=e,Aa=Ea=Ra=0;!Ka();)Za(xa=Ja())?Ya(xa):91===xa&&Xa(xa);return{exp:e.slice(0,Ea),key:e.slice(Ea+1,Ra)}}(e);return null===n.key?e+"="+t:"$set("+n.exp+", "+n.key+", "+t+")"}function Ja(){return _a.charCodeAt(++Aa)}function Ka(){return Aa>=Ca}function Za(e){return 34===e||39===e}function Xa(e){var t=1;for(Ea=Aa;!Ka();)if(Za(e=Ja()))Ya(e);else if(91===e&&t++,93===e&&t--,0===t){Ra=Aa;break}}function Ya(e){for(var t=e;!Ka()&&(e=Ja())!==t;);}var Qa,ei="__r",ti="__c";function ni(e,t,n){var a=Qa;return function i(){null!==t.apply(null,arguments)&&ri(e,i,n,a)}}var ai=Je&&!(Q&&Number(Q[1])<=53);function ii(e,t,n,a){if(ai){var i=mn,r=t;t=r._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return r.apply(this,arguments)}}Qa.addEventListener(e,t,te?{capture:n,passive:a}:n)}function ri(e,t,n,a){(a||Qa).removeEventListener(e,t._wrapper||t,n)}function si(e,n){if(!t(e.data.on)||!t(n.data.on)){var i=n.data.on||{},r=e.data.on||{};Qa=n.elm,function(e){if(a(e[ei])){var t=K?"change":"input";e[t]=[].concat(e[ei],e[t]||[]),delete e[ei]}a(e[ti])&&(e.change=[].concat(e[ti],e.change||[]),delete e[ti])}(i),lt(i,r,ii,ri,ni,n.context),Qa=void 0}}var oi,li={create:si,update:si};function di(e,n){if(!t(e.data.domProps)||!t(n.data.domProps)){var i,r,s=n.elm,o=e.data.domProps||{},l=n.data.domProps||{};for(i in a(l.__ob__)&&(l=n.data.domProps=A({},l)),o)i in l||(s[i]="");for(i in l){if(r=l[i],"textContent"===i||"innerHTML"===i){if(n.children&&(n.children.length=0),r===o[i])continue;1===s.childNodes.length&&s.removeChild(s.childNodes[0])}if("value"===i&&"PROGRESS"!==s.tagName){s._value=r;var d=t(r)?"":String(r);ui(s,d)&&(s.value=d)}else if("innerHTML"===i&&Qn(s.tagName)&&t(s.innerHTML)){(oi=oi||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var u=oi.firstChild;s.firstChild;)s.removeChild(s.firstChild);for(;u.firstChild;)s.appendChild(u.firstChild)}else if(r!==o[i])try{s[i]=r}catch(e){}}}}function ui(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,i=e._vModifiers;if(a(i)){if(i.number)return c(n)!==c(t);if(i.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var pi={create:di,update:di},ci=g((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function yi(e){var t=mi(e.style);return e.staticStyle?A(e.staticStyle,t):t}function mi(e){return Array.isArray(e)?E(e):"string"==typeof e?ci(e):e}var fi,hi=/^--/,vi=/\s*!important$/,bi=function(e,t,n){if(hi.test(t))e.style.setProperty(t,n);else if(vi.test(n))e.style.setProperty(C(t),n.replace(vi,""),"important");else{var a=Ti(t);if(Array.isArray(n))for(var i=0,r=n.length;i<r;i++)e.style[a]=n[i];else e.style[a]=n}},gi=["Webkit","Moz","ms"],Ti=g((function(e){if(fi=fi||document.createElement("div").style,"filter"!==(e=w(e))&&e in fi)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<gi.length;n++){var a=gi[n]+t;if(a in fi)return a}}));function wi(e,n){var i=n.data,r=e.data;if(!(t(i.staticStyle)&&t(i.style)&&t(r.staticStyle)&&t(r.style))){var s,o,l=n.elm,d=r.staticStyle,u=r.normalizedStyle||r.style||{},p=d||u,c=mi(n.data.style)||{};n.data.normalizedStyle=a(c.__ob__)?A({},c):c;var y=function(e,t){for(var n,a={},i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=yi(i.data))&&A(a,n);(n=yi(e.data))&&A(a,n);for(var r=e;r=r.parent;)r.data&&(n=yi(r.data))&&A(a,n);return a}(n);for(o in p)t(y[o])&&bi(l,o,"");for(o in y)(s=y[o])!==p[o]&&bi(l,o,null==s?"":s)}}var ki={create:wi,update:wi},Ii=/\s+/;function Ci(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ii).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" "+(e.getAttribute("class")||"")+" ";n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function _i(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(Ii).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" "+(e.getAttribute("class")||"")+" ",a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function xi(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&A(t,Ai(e.name||"v")),A(t,e),t}return"string"==typeof e?Ai(e):void 0}}var Ai=g((function(e){return{enterClass:e+"-enter",enterToClass:e+"-enter-to",enterActiveClass:e+"-enter-active",leaveClass:e+"-leave",leaveToClass:e+"-leave-to",leaveActiveClass:e+"-leave-active"}})),Ei=q&&!Z,Ri="transition",Oi="animation",Mi="transition",Si="transitionend",Pi="animation",$i="animationend";Ei&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Mi="WebkitTransition",Si="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Pi="WebkitAnimation",$i="webkitAnimationEnd"));var Li=q?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function Fi(e){Li((function(){Li(e)}))}function Di(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),Ci(e,t))}function Vi(e,t){e._transitionClasses&&h(e._transitionClasses,t),_i(e,t)}function Hi(e,t,n){var a=Ni(e,t),i=a.type,r=a.timeout,s=a.propCount;if(!i)return n();var o=i===Ri?Si:$i,l=0,d=function(){e.removeEventListener(o,u),n()},u=function(t){t.target===e&&++l>=s&&d()};setTimeout((function(){l<s&&d()}),r+1),e.addEventListener(o,u)}var ji=/\b(transform|all)(,|$)/;function Ni(e,t){var n,a=window.getComputedStyle(e),i=(a[Mi+"Delay"]||"").split(", "),r=(a[Mi+"Duration"]||"").split(", "),s=Bi(i,r),o=(a[Pi+"Delay"]||"").split(", "),l=(a[Pi+"Duration"]||"").split(", "),d=Bi(o,l),u=0,p=0;return t===Ri?s>0&&(n=Ri,u=s,p=r.length):t===Oi?d>0&&(n=Oi,u=d,p=l.length):p=(n=(u=Math.max(s,d))>0?s>d?Ri:Oi:null)?n===Ri?r.length:l.length:0,{type:n,timeout:u,propCount:p,hasTransform:n===Ri&&ji.test(a[Mi+"Property"])}}function Bi(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return Ui(t)+Ui(e[n])})))}function Ui(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function zi(e,n){var i=e.elm;a(i._leaveCb)&&(i._leaveCb.cancelled=!0,i._leaveCb());var r=xi(e.data.transition);if(!t(r)&&!a(i._enterCb)&&1===i.nodeType){for(var o=r.css,l=r.type,d=r.enterClass,u=r.enterToClass,p=r.enterActiveClass,y=r.appearClass,m=r.appearToClass,f=r.appearActiveClass,h=r.beforeEnter,v=r.enter,b=r.afterEnter,g=r.enterCancelled,T=r.beforeAppear,w=r.appear,k=r.afterAppear,I=r.appearCancelled,C=r.duration,_=tn,x=tn.$vnode;x&&x.parent;)_=x.context,x=x.parent;var A=!_._isMounted||!e.isRootInsert;if(!A||w||""===w){var E=A&&y?y:d,R=A&&f?f:p,O=A&&m?m:u,M=A&&T||h,S=A&&"function"==typeof w?w:v,P=A&&k||b,L=A&&I||g,F=c(s(C)?C.enter:C),D=!1!==o&&!Z,V=Gi(S),H=i._enterCb=$((function(){D&&(Vi(i,O),Vi(i,R)),H.cancelled?(D&&Vi(i,E),L&&L(i)):P&&P(i),i._enterCb=null}));e.data.show||dt(e,"insert",(function(){var t=i.parentNode,n=t&&t._pending&&t._pending[e.key];n&&n.tag===e.tag&&n.elm._leaveCb&&n.elm._leaveCb(),S&&S(i,H)})),M&&M(i),D&&(Di(i,E),Di(i,R),Fi((function(){Vi(i,E),H.cancelled||(Di(i,O),V||(Wi(F)?setTimeout(H,F):Hi(i,l,H)))}))),e.data.show&&(n&&n(),S&&S(i,H)),D||V||H()}}}function qi(e,n){var i=e.elm;a(i._enterCb)&&(i._enterCb.cancelled=!0,i._enterCb());var r=xi(e.data.transition);if(t(r)||1!==i.nodeType)return n();if(!a(i._leaveCb)){var o=r.css,l=r.type,d=r.leaveClass,u=r.leaveToClass,p=r.leaveActiveClass,y=r.beforeLeave,m=r.leave,f=r.afterLeave,h=r.leaveCancelled,v=r.delayLeave,b=r.duration,g=!1!==o&&!Z,T=Gi(m),w=c(s(b)?b.leave:b),k=i._leaveCb=$((function(){i.parentNode&&i.parentNode._pending&&(i.parentNode._pending[e.key]=null),g&&(Vi(i,u),Vi(i,p)),k.cancelled?(g&&Vi(i,d),h&&h(i)):(n(),f&&f(i)),i._leaveCb=null}));v?v(I):I()}function I(){k.cancelled||(!e.data.show&&i.parentNode&&((i.parentNode._pending||(i.parentNode._pending={}))[e.key]=e),y&&y(i),g&&(Di(i,d),Di(i,p),Fi((function(){Vi(i,d),k.cancelled||(Di(i,u),T||(Wi(w)?setTimeout(k,w):Hi(i,l,k)))}))),m&&m(i,k),g||T||k())}}function Wi(e){return"number"==typeof e&&!isNaN(e)}function Gi(e){if(t(e))return!1;var n=e.fns;return a(n)?Gi(Array.isArray(n)?n[0]:n):(e._length||e.length)>1}function Ji(e,t){!0!==t.data.show&&zi(t)}var Ki=function(e){var n,s,o={},l=e.modules,d=e.nodeOps;for(n=0;n<da.length;++n)for(o[da[n]]=[],s=0;s<l.length;++s)a(l[s][da[n]])&&o[da[n]].push(l[s][da[n]]);function u(e){var t=d.parentNode(e);a(t)&&d.removeChild(t,e)}function p(e,t,n,r,s,l,u){if(a(e.elm)&&a(l)&&(e=l[u]=be(e)),e.isRootInsert=!s,!function(e,t,n,r){var s=e.data;if(a(s)){var l=a(e.componentInstance)&&s.keepAlive;if(a(s=s.hook)&&a(s=s.init)&&s(e,!1),a(e.componentInstance))return c(e,t),m(n,e.elm,r),i(l)&&function(e,t,n,i){for(var r,s=e;s.componentInstance;)if(a(r=(s=s.componentInstance._vnode).data)&&a(r=r.transition)){for(r=0;r<o.activate.length;++r)o.activate[r](la,s);t.push(s);break}m(n,e.elm,i)}(e,t,n,r),!0}}(e,t,n,r)){var p=e.data,y=e.children,h=e.tag;a(h)?(e.elm=e.ns?d.createElementNS(e.ns,h):d.createElement(h,e),b(e),f(e,y,t),a(p)&&v(e,t),m(n,e.elm,r)):i(e.isComment)?(e.elm=d.createComment(e.text),m(n,e.elm,r)):(e.elm=d.createTextNode(e.text),m(n,e.elm,r))}}function c(e,t){a(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,h(e)?(v(e,t),b(e)):(oa(e),t.push(e))}function m(e,t,n){a(e)&&(a(n)?d.parentNode(n)===e&&d.insertBefore(e,t,n):d.appendChild(e,t))}function f(e,t,n){if(Array.isArray(t))for(var a=0;a<t.length;++a)p(t[a],n,e.elm,null,!0,t,a);else r(e.text)&&d.appendChild(e.elm,d.createTextNode(String(e.text)))}function h(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return a(e.tag)}function v(e,t){for(var i=0;i<o.create.length;++i)o.create[i](la,e);a(n=e.data.hook)&&(a(n.create)&&n.create(la,e),a(n.insert)&&t.push(e))}function b(e){var t;if(a(t=e.fnScopeId))d.setStyleScope(e.elm,t);else for(var n=e;n;)a(t=n.context)&&a(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t),n=n.parent;a(t=tn)&&t!==e.context&&t!==e.fnContext&&a(t=t.$options._scopeId)&&d.setStyleScope(e.elm,t)}function g(e,t,n,a,i,r){for(;a<=i;++a)p(n[a],r,e,t,!1,n,a)}function T(e){var t,n,i=e.data;if(a(i))for(a(t=i.hook)&&a(t=t.destroy)&&t(e),t=0;t<o.destroy.length;++t)o.destroy[t](e);if(a(t=e.children))for(n=0;n<e.children.length;++n)T(e.children[n])}function w(e,t,n){for(;t<=n;++t){var i=e[t];a(i)&&(a(i.tag)?(k(i),T(i)):u(i.elm))}}function k(e,t){if(a(t)||a(e.data)){var n,i=o.remove.length+1;for(a(t)?t.listeners+=i:t=function(e,t){function n(){0==--n.listeners&&u(e)}return n.listeners=t,n}(e.elm,i),a(n=e.componentInstance)&&a(n=n._vnode)&&a(n.data)&&k(n,t),n=0;n<o.remove.length;++n)o.remove[n](e,t);a(n=e.data.hook)&&a(n=n.remove)?n(e,t):t()}else u(e.elm)}function I(e,t,n,i){for(var r=n;r<i;r++){var s=t[r];if(a(s)&&ua(e,s))return r}}function C(e,n,r,s,l,u){if(e!==n){a(n.elm)&&a(s)&&(n=s[l]=be(n));var c=n.elm=e.elm;if(i(e.isAsyncPlaceholder))a(n.asyncFactory.resolved)?A(e.elm,n,r):n.isAsyncPlaceholder=!0;else if(i(n.isStatic)&&i(e.isStatic)&&n.key===e.key&&(i(n.isCloned)||i(n.isOnce)))n.componentInstance=e.componentInstance;else{var y,m=n.data;a(m)&&a(y=m.hook)&&a(y=y.prepatch)&&y(e,n);var f=e.children,v=n.children;if(a(m)&&h(n)){for(y=0;y<o.update.length;++y)o.update[y](e,n);a(y=m.hook)&&a(y=y.update)&&y(e,n)}t(n.text)?a(f)&&a(v)?f!==v&&function(e,n,i,r,s){for(var o,l,u,c=0,y=0,m=n.length-1,f=n[0],h=n[m],v=i.length-1,b=i[0],T=i[v],k=!s;c<=m&&y<=v;)t(f)?f=n[++c]:t(h)?h=n[--m]:ua(f,b)?(C(f,b,r,i,y),f=n[++c],b=i[++y]):ua(h,T)?(C(h,T,r,i,v),h=n[--m],T=i[--v]):ua(f,T)?(C(f,T,r,i,v),k&&d.insertBefore(e,f.elm,d.nextSibling(h.elm)),f=n[++c],T=i[--v]):ua(h,b)?(C(h,b,r,i,y),k&&d.insertBefore(e,h.elm,f.elm),h=n[--m],b=i[++y]):(t(o)&&(o=pa(n,c,m)),t(l=a(b.key)?o[b.key]:I(b,n,c,m))?p(b,r,e,f.elm,!1,i,y):ua(u=n[l],b)?(C(u,b,r,i,y),n[l]=void 0,k&&d.insertBefore(e,u.elm,f.elm)):p(b,r,e,f.elm,!1,i,y),b=i[++y]);c>m?g(e,t(i[v+1])?null:i[v+1].elm,i,y,v,r):y>v&&w(n,c,m)}(c,f,v,r,u):a(v)?(a(e.text)&&d.setTextContent(c,""),g(c,null,v,0,v.length-1,r)):a(f)?w(f,0,f.length-1):a(e.text)&&d.setTextContent(c,""):e.text!==n.text&&d.setTextContent(c,n.text),a(m)&&a(y=m.hook)&&a(y=y.postpatch)&&y(e,n)}}}function _(e,t,n){if(i(n)&&a(e.parent))e.parent.data.pendingInsert=t;else for(var r=0;r<t.length;++r)t[r].data.hook.insert(t[r])}var x=y("attrs,class,staticClass,staticStyle,key");function A(e,t,n,r){var s,o=t.tag,l=t.data,d=t.children;if(r=r||l&&l.pre,t.elm=e,i(t.isComment)&&a(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(a(l)&&(a(s=l.hook)&&a(s=s.init)&&s(t,!0),a(s=t.componentInstance)))return c(t,n),!0;if(a(o)){if(a(d))if(e.hasChildNodes())if(a(s=l)&&a(s=s.domProps)&&a(s=s.innerHTML)){if(s!==e.innerHTML)return!1}else{for(var u=!0,p=e.firstChild,y=0;y<d.length;y++){if(!p||!A(p,d[y],n,r)){u=!1;break}p=p.nextSibling}if(!u||p)return!1}else f(t,d,n);if(a(l)){var m=!1;for(var h in l)if(!x(h)){m=!0,v(t,n);break}!m&&l.class&&it(l.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,n,r,s){if(!t(n)){var l,u=!1,c=[];if(t(e))u=!0,p(n,c);else{var y=a(e.nodeType);if(!y&&ua(e,n))C(e,n,c,null,null,s);else{if(y){if(1===e.nodeType&&e.hasAttribute(L)&&(e.removeAttribute(L),r=!0),i(r)&&A(e,n,c))return _(n,c,!0),e;l=e,e=new me(d.tagName(l).toLowerCase(),{},[],void 0,l)}var m=e.elm,f=d.parentNode(m);if(p(n,c,m._leaveCb?null:f,d.nextSibling(m)),a(n.parent))for(var v=n.parent,b=h(n);v;){for(var g=0;g<o.destroy.length;++g)o.destroy[g](v);if(v.elm=n.elm,b){for(var k=0;k<o.create.length;++k)o.create[k](la,v);var I=v.data.hook.insert;if(I.merged)for(var x=1;x<I.fns.length;x++)I.fns[x]()}else oa(v);v=v.parent}a(f)?w([e],0,0):a(e.tag)&&T(e)}}return _(n,c,u),n.elm}a(e)&&T(e)}}({nodeOps:ra,modules:[ka,Oa,li,pi,ki,q?{create:Ji,activate:Ji,remove:function(e,t){!0!==e.data.show?qi(e,t):t()}}:{}].concat(ba)});Z&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&ar(e,"input")}));var Zi={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?dt(n,"postpatch",(function(){Zi.componentUpdated(e,t,n)})):Xi(e,t,n.context),e._vOptions=[].map.call(e.options,er)):("textarea"===n.tag||aa(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",tr),e.addEventListener("compositionend",nr),e.addEventListener("change",nr),Z&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){Xi(e,t,n.context);var a=e._vOptions,i=e._vOptions=[].map.call(e.options,er);i.some((function(e,t){return!S(e,a[t])}))&&(e.multiple?t.value.some((function(e){return Qi(e,i)})):t.value!==t.oldValue&&Qi(t.value,i))&&ar(e,"change")}}};function Xi(e,t,n){Yi(e,t),(K||X)&&setTimeout((function(){Yi(e,t)}),0)}function Yi(e,t,n){var a=t.value,i=e.multiple;if(!i||Array.isArray(a)){for(var r,s,o=0,l=e.options.length;o<l;o++)if(s=e.options[o],i)r=P(a,er(s))>-1,s.selected!==r&&(s.selected=r);else if(S(er(s),a))return void(e.selectedIndex!==o&&(e.selectedIndex=o));i||(e.selectedIndex=-1)}}function Qi(e,t){return t.every((function(t){return!S(t,e)}))}function er(e){return"_value"in e?e._value:e.value}function tr(e){e.target.composing=!0}function nr(e){e.target.composing&&(e.target.composing=!1,ar(e.target,"input"))}function ar(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function ir(e){return!e.componentInstance||e.data&&e.data.transition?e:ir(e.componentInstance._vnode)}var rr={bind:function(e,t,n){var a=t.value,i=(n=ir(n)).data&&n.data.transition,r=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&i?(n.data.show=!0,zi(n,(function(){e.style.display=r}))):e.style.display=a?r:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=ir(n)).data&&n.data.transition?(n.data.show=!0,a?zi(n,(function(){e.style.display=e.__vOriginalDisplay})):qi(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,i){i||(e.style.display=e.__vOriginalDisplay)}},sr={model:Zi,show:rr},or={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function lr(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?lr(Zt(t.children)):e}function dr(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var i=n._parentListeners;for(var r in i)t[w(r)]=i[r];return t}function ur(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var pr=function(e){return e.tag||vt(e)},cr=function(e){return"show"===e.name},yr={name:"transition",props:or,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(pr)).length){var a=this.mode,i=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return i;var s=lr(i);if(!s)return i;if(this._leaving)return ur(e,i);var o="__transition-"+this._uid+"-";s.key=null==s.key?s.isComment?o+"comment":o+s.tag:r(s.key)?0===String(s.key).indexOf(o)?s.key:o+s.key:s.key;var l=(s.data||(s.data={})).transition=dr(this),d=this._vnode,u=lr(d);if(s.data.directives&&s.data.directives.some(cr)&&(s.data.show=!0),u&&u.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(s,u)&&!vt(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var p=u.data.transition=A({},l);if("out-in"===a)return this._leaving=!0,dt(p,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),ur(e,i);if("in-out"===a){if(vt(s))return d;var c,y=function(){c()};dt(l,"afterEnter",y),dt(l,"enterCancelled",y),dt(p,"delayLeave",(function(e){c=e}))}}return i}}},mr=A({tag:String,moveClass:String},or);delete mr.mode;var fr={props:mr,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var i=nn(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],r=this.children=[],s=dr(this),o=0;o<i.length;o++){var l=i[o];l.tag&&null!=l.key&&0!==String(l.key).indexOf("__vlist")&&(r.push(l),n[l.key]=l,(l.data||(l.data={})).transition=s)}if(a){for(var d=[],u=[],p=0;p<a.length;p++){var c=a[p];c.data.transition=s,c.data.pos=c.elm.getBoundingClientRect(),n[c.key]?d.push(c):u.push(c)}this.kept=e(t,null,d),this.removed=u}return e(t,null,r)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(hr),e.forEach(vr),e.forEach(br),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;Di(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(Si,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(Si,e),n._moveCb=null,Vi(n,t))})}})))},methods:{hasMove:function(e,t){if(!Ei)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){_i(n,e)})),Ci(n,t),n.style.display="none",this.$el.appendChild(n);var a=Ni(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}};function hr(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function vr(e){e.data.newPos=e.elm.getBoundingClientRect()}function br(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,i=t.top-n.top;if(a||i){e.data.moved=!0;var r=e.elm.style;r.transform=r.WebkitTransform="translate("+a+"px,"+i+"px)",r.transitionDuration="0s"}}var gr={Transition:yr,TransitionGroup:fr};Rn.config.mustUseProp=Hn,Rn.config.isReservedTag=ea,Rn.config.isReservedAttr=Dn,Rn.config.getTagNamespace=ta,Rn.config.isUnknownElement=function(e){if(!q)return!0;if(ea(e))return!1;if(e=e.toLowerCase(),null!=na[e])return na[e];var t=document.createElement(e);return e.indexOf("-")>-1?na[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:na[e]=/HTMLUnknownElement/.test(t.toString())},A(Rn.options.directives,sr),A(Rn.options.components,gr),Rn.prototype.__patch__=q?Ki:R,Rn.prototype.$mount=function(e,t){return function(e,t,n){var a;return e.$el=t,e.$options.render||(e.$options.render=he),on(e,"beforeMount"),a=function(){e._update(e._render(),n)},new gn(e,a,R,{before:function(){e._isMounted&&!e._isDestroyed&&on(e,"beforeUpdate")}},!0),n=!1,null==e.$vnode&&(e._isMounted=!0,on(e,"mounted")),e}(this,e=e&&q?ia(e):void 0,t)},q&&setTimeout((function(){V.devtools&&ie&&ie.emit("init",Rn)}),0);var Tr,wr=/\{\{((?:.|\r?\n)+?)\}\}/g,kr=/[-.*+?^${}()|[\]\/\\]/g,Ir=g((function(e){var t=e[0].replace(kr,"\\$&"),n=e[1].replace(kr,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")})),Cr={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=Ua(e,"class");n&&(e.staticClass=JSON.stringify(n));var a=Ba(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:"+e.staticClass+","),e.classBinding&&(t+="class:"+e.classBinding+","),t}},_r={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=Ua(e,"style");n&&(e.staticStyle=JSON.stringify(ci(n)));var a=Ba(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:"+e.staticStyle+","),e.styleBinding&&(t+="style:("+e.styleBinding+"),"),t}},xr=y("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Ar=y("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Er=y("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),Rr=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Or=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Mr="[a-zA-Z_][\\-\\.0-9_a-zA-Z"+H.source+"]*",Sr="((?:"+Mr+"\\:)?"+Mr+")",Pr=new RegExp("^<"+Sr),$r=/^\s*(\/?)>/,Lr=new RegExp("^<\\/"+Sr+"[^>]*>"),Fr=/^<!DOCTYPE [^>]+>/i,Dr=/^<!\--/,Vr=/^<!\[/,Hr=y("script,style,textarea",!0),jr={},Nr={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},Br=/&(?:lt|gt|quot|amp|#39);/g,Ur=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,zr=y("pre,textarea",!0),qr=function(e,t){return e&&zr(e)&&"\n"===t[0]};function Wr(e,t){var n=t?Ur:Br;return e.replace(n,(function(e){return Nr[e]}))}var Gr,Jr,Kr,Zr,Xr,Yr,Qr,es,ts=/^@|^v-on:/,ns=/^v-|^@|^:|^#/,as=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,is=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,rs=/^\(|\)$/g,ss=/^\[.*\]$/,os=/:(.*)$/,ls=/^:|^\.|^v-bind:/,ds=/\.[^.\]]+(?=[^\]]*$)/g,us=/^v-slot(:|$)|^#/,ps=/[\r\n]/,cs=/[ \f\t\r\n]+/g,ys=g((function(e){return(Tr=Tr||document.createElement("div")).innerHTML=e,Tr.textContent})),ms="_empty_";function fs(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:ws(t),rawAttrsMap:{},parent:n,children:[]}}function hs(e,t){var n;!function(e){var t=Ba(e,"key");t&&(e.key=t)}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=Ba(e,"ref");t&&(e.ref=t,e.refInFor=function(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=Ua(e,"scope"),e.slotScope=t||Ua(e,"slot-scope")):(t=Ua(e,"slot-scope"))&&(e.slotScope=t);var n=Ba(e,"slot");if(n&&(e.slotTarget='""'===n?'"default"':n,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||Da(e,"slot",n,function(e,t){return e.rawAttrsMap[":"+t]||e.rawAttrsMap["v-bind:"+t]||e.rawAttrsMap[t]}(e,"slot"))),"template"===e.tag){var a=za(e,us);if(a){var i=gs(a),r=i.name,s=i.dynamic;e.slotTarget=r,e.slotTargetDynamic=s,e.slotScope=a.value||ms}}else{var o=za(e,us);if(o){var l=e.scopedSlots||(e.scopedSlots={}),d=gs(o),u=d.name,p=d.dynamic,c=l[u]=fs("template",[],e);c.slotTarget=u,c.slotTargetDynamic=p,c.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=c,!0})),c.slotScope=o.value||ms,e.children=[],e.plain=!1}}}(e),"slot"===(n=e).tag&&(n.slotName=Ba(n,"name")),function(e){var t;(t=Ba(e,"is"))&&(e.component=t),null!=Ua(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<Kr.length;a++)e=Kr[a](e,t)||e;return function(e){var t,n,a,i,r,s,o,l,d=e.attrsList;for(t=0,n=d.length;t<n;t++)if(a=i=d[t].name,r=d[t].value,ns.test(a))if(e.hasBindings=!0,(s=Ts(a.replace(ns,"")))&&(a=a.replace(ds,"")),ls.test(a))a=a.replace(ls,""),r=Sa(r),(l=ss.test(a))&&(a=a.slice(1,-1)),s&&(s.prop&&!l&&"innerHtml"===(a=w(a))&&(a="innerHTML"),s.camel&&!l&&(a=w(a)),s.sync&&(o=Ga(r,"$event"),l?Na(e,'"update:"+('+a+")",o,null,!1,0,d[t],!0):(Na(e,"update:"+w(a),o,null,!1,0,d[t]),C(a)!==w(a)&&Na(e,"update:"+C(a),o,null,!1,0,d[t])))),s&&s.prop||!e.component&&Qr(e.tag,e.attrsMap.type,a)?Fa(e,a,r,d[t],l):Da(e,a,r,d[t],l);else if(ts.test(a))a=a.replace(ts,""),(l=ss.test(a))&&(a=a.slice(1,-1)),Na(e,a,r,s,!1,0,d[t],l);else{var u=(a=a.replace(ns,"")).match(os),p=u&&u[1];l=!1,p&&(a=a.slice(0,-(p.length+1)),ss.test(p)&&(p=p.slice(1,-1),l=!0)),Ha(e,a,i,r,p,l,s,d[t])}else Da(e,a,JSON.stringify(r),d[t]),!e.component&&"muted"===a&&Qr(e.tag,e.attrsMap.type,a)&&Fa(e,a,"true",d[t])}(e),e}function vs(e){var t;if(t=Ua(e,"v-for")){var n=function(e){var t=e.match(as);if(t){var n={};n.for=t[2].trim();var a=t[1].trim().replace(rs,""),i=a.match(is);return i?(n.alias=a.replace(is,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=a,n}}(t);n&&A(e,n)}}function bs(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function gs(e){var t=e.name.replace(us,"");return t||"#"!==e.name[0]&&(t="default"),ss.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'+t+'"',dynamic:!1}}function Ts(e){var t=e.match(ds);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function ws(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var ks=/^xmlns:NS\d+/,Is=/^NS\d+:/;function Cs(e){return fs(e.tag,e.attrsList.slice(),e.parent)}var _s,xs,As,Es=[Cr,_r,{preTransformNode:function(e,t){if("input"===e.tag){var n,a=e.attrsMap;if(!a["v-model"])return;if((a[":type"]||a["v-bind:type"])&&(n=Ba(e,"type")),a.type||n||!a["v-bind"]||(n="("+a["v-bind"]+").type"),n){var i=Ua(e,"v-if",!0),r=i?"&&("+i+")":"",s=null!=Ua(e,"v-else",!0),o=Ua(e,"v-else-if",!0),l=Cs(e);vs(l),Va(l,"type","checkbox"),hs(l,t),l.processed=!0,l.if="("+n+")==='checkbox'"+r,bs(l,{exp:l.if,block:l});var d=Cs(e);Ua(d,"v-for",!0),Va(d,"type","radio"),hs(d,t),bs(l,{exp:"("+n+")==='radio'"+r,block:d});var u=Cs(e);return Ua(u,"v-for",!0),Va(u,":type",n),hs(u,t),bs(l,{exp:i,block:u}),s?l.else=!0:o&&(l.elseif=o),l}}}}],Rs={model:function(e,t,n){var a=t.value,i=t.modifiers,r=e.tag,s=e.attrsMap.type;if(e.component)return Wa(e,a,i),!1;if("select"===r)!function(e,t,n){var a='var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return '+(n&&n.number?"_n(val)":"val")+"});";Na(e,"change",a=a+" "+Ga(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]"),null,!0)}(e,a,i);else if("input"===r&&"checkbox"===s)!function(e,t,n){var a=n&&n.number,i=Ba(e,"value")||"null",r=Ba(e,"true-value")||"true",s=Ba(e,"false-value")||"false";Fa(e,"checked","Array.isArray("+t+")?_i("+t+","+i+")>-1"+("true"===r?":("+t+")":":_q("+t+","+r+")")),Na(e,"change","var $$a="+t+",$$el=$event.target,$$c=$$el.checked?("+r+"):("+s+");if(Array.isArray($$a)){var $$v="+(a?"_n("+i+")":i)+",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&("+Ga(t,"$$a.concat([$$v])")+")}else{$$i>-1&&("+Ga(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))")+")}}else{"+Ga(t,"$$c")+"}",null,!0)}(e,a,i);else if("input"===r&&"radio"===s)!function(e,t,n){var a=n&&n.number,i=Ba(e,"value")||"null";Fa(e,"checked","_q("+t+","+(i=a?"_n("+i+")":i)+")"),Na(e,"change",Ga(t,i),null,!0)}(e,a,i);else if("input"===r||"textarea"===r)!function(e,t,n){var a=e.attrsMap.type,i=n||{},r=i.lazy,s=i.number,o=i.trim,l=!r&&"range"!==a,d=r?"change":"range"===a?ei:"input",u="$event.target.value";o&&(u="$event.target.value.trim()"),s&&(u="_n("+u+")");var p=Ga(t,u);l&&(p="if($event.target.composing)return;"+p),Fa(e,"value","("+t+")"),Na(e,d,p,null,!0),(o||s)&&Na(e,"blur","$forceUpdate()")}(e,a,i);else if(!V.isReservedTag(r))return Wa(e,a,i),!1;return!0},text:function(e,t){t.value&&Fa(e,"textContent","_s("+t.value+")",t)},html:function(e,t){t.value&&Fa(e,"innerHTML","_s("+t.value+")",t)}},Os={expectHTML:!0,modules:Es,directives:Rs,isPreTag:function(e){return"pre"===e},isUnaryTag:xr,mustUseProp:Hn,canBeLeftOpenTag:Ar,isReservedTag:ea,getTagNamespace:ta,staticKeys:(As=Es,As.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(","))},Ms=g((function(e){return y("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function Ss(e,t){e&&(_s=Ms(t.staticKeys||""),xs=t.isReservedTag||O,Ps(e),$s(e,!1))}function Ps(e){if(e.static=function(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||m(e.tag)||!xs(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(_s))))}(e),1===e.type){if(!xs(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var a=e.children[t];Ps(a),a.static||(e.static=!1)}if(e.ifConditions)for(var i=1,r=e.ifConditions.length;i<r;i++){var s=e.ifConditions[i].block;Ps(s),s.static||(e.static=!1)}}}function $s(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,a=e.children.length;n<a;n++)$s(e.children[n],t||!!e.for);if(e.ifConditions)for(var i=1,r=e.ifConditions.length;i<r;i++)$s(e.ifConditions[i].block,t)}}var Ls=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Fs=/\([^)]*?\);*$/,Ds=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,Vs={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},Hs={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},js=function(e){return"if("+e+")return null;"},Ns={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:js("$event.target !== $event.currentTarget"),ctrl:js("!$event.ctrlKey"),shift:js("!$event.shiftKey"),alt:js("!$event.altKey"),meta:js("!$event.metaKey"),left:js("'button' in $event && $event.button !== 0"),middle:js("'button' in $event && $event.button !== 1"),right:js("'button' in $event && $event.button !== 2")};function Bs(e,t){var n=t?"nativeOn:":"on:",a="",i="";for(var r in e){var s=Us(e[r]);e[r]&&e[r].dynamic?i+=r+","+s+",":a+='"'+r+'":'+s+","}return a="{"+a.slice(0,-1)+"}",i?n+"_d("+a+",["+i.slice(0,-1)+"])":n+a}function Us(e){if(!e)return"function(){}";if(Array.isArray(e))return"["+e.map((function(e){return Us(e)})).join(",")+"]";var t=Ds.test(e.value),n=Ls.test(e.value),a=Ds.test(e.value.replace(Fs,""));if(e.modifiers){var i="",r="",s=[];for(var o in e.modifiers)if(Ns[o])r+=Ns[o],Vs[o]&&s.push(o);else if("exact"===o){var l=e.modifiers;r+=js(["ctrl","shift","alt","meta"].filter((function(e){return!l[e]})).map((function(e){return"$event."+e+"Key"})).join("||"))}else s.push(o);return s.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+e.map(zs).join("&&")+")return null;"}(s)),r&&(i+=r),"function($event){"+i+(t?"return "+e.value+".apply(null, arguments)":n?"return ("+e.value+").apply(null, arguments)":a?"return "+e.value:e.value)+"}"}return t||n?e.value:"function($event){"+(a?"return "+e.value:e.value)+"}"}function zs(e){var t=parseInt(e,10);if(t)return"$event.keyCode!=="+t;var n=Vs[e],a=Hs[e];return"_k($event.keyCode,"+JSON.stringify(e)+","+JSON.stringify(n)+",$event.key,"+JSON.stringify(a)+")"}var qs={on:function(e,t){e.wrapListeners=function(e){return"_g("+e+","+t.value+")"}},bind:function(e,t){e.wrapData=function(n){return"_b("+n+",'"+e.tag+"',"+t.value+","+(t.modifiers&&t.modifiers.prop?"true":"false")+(t.modifiers&&t.modifiers.sync?",true":"")+")"}},cloak:R},Ws=function(e){this.options=e,this.warn=e.warn||$a,this.transforms=La(e.modules,"transformCode"),this.dataGenFns=La(e.modules,"genData"),this.directives=A(A({},qs),e.directives);var t=e.isReservedTag||O;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function Gs(e,t){var n=new Ws(t);return{render:"with(this){return "+(e?"script"===e.tag?"null":Js(e,n):'_c("div")')+"}",staticRenderFns:n.staticRenderFns}}function Js(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return Ks(e,t);if(e.once&&!e.onceProcessed)return Zs(e,t);if(e.for&&!e.forProcessed)return Qs(e,t);if(e.if&&!e.ifProcessed)return Xs(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=ao(e,t),i="_t("+n+(a?",function(){return "+a+"}":""),r=e.attrs||e.dynamicAttrs?so((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:w(e.name),value:e.value,dynamic:e.dynamic}}))):null,s=e.attrsMap["v-bind"];return!r&&!s||a||(i+=",null"),r&&(i+=","+r),s&&(i+=(r?"":",null")+","+s),i+")"}(e,t);var n;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:ao(t,n,!0);return"_c("+e+","+eo(t,n)+(a?","+a:"")+")"}(e.component,e,t);else{var a;(!e.plain||e.pre&&t.maybeComponent(e))&&(a=eo(e,t));var i=e.inlineTemplate?null:ao(e,t,!0);n="_c('"+e.tag+"'"+(a?","+a:"")+(i?","+i:"")+")"}for(var r=0;r<t.transforms.length;r++)n=t.transforms[r](e,n);return n}return ao(e,t)||"void 0"}function Ks(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return "+Js(e,t)+"}"),t.pre=n,"_m("+(t.staticRenderFns.length-1)+(e.staticInFor?",true":"")+")"}function Zs(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return Xs(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o("+Js(e,t)+","+t.onceId+++","+n+")":Js(e,t)}return Ks(e,t)}function Xs(e,t,n,a){return e.ifProcessed=!0,Ys(e.ifConditions.slice(),t,n,a)}function Ys(e,t,n,a){if(!e.length)return a||"_e()";var i=e.shift();return i.exp?"("+i.exp+")?"+r(i.block)+":"+Ys(e,t,n,a):""+r(i.block);function r(e){return n?n(e,t):e.once?Zs(e,t):Js(e,t)}}function Qs(e,t,n,a){var i=e.for,r=e.alias,s=e.iterator1?","+e.iterator1:"",o=e.iterator2?","+e.iterator2:"";return e.forProcessed=!0,(a||"_l")+"(("+i+"),function("+r+s+o+"){return "+(n||Js)(e,t)+"})"}function eo(e,t){var n="{",a=function(e,t){var n=e.directives;if(n){var a,i,r,s,o="directives:[",l=!1;for(a=0,i=n.length;a<i;a++){r=n[a],s=!0;var d=t.directives[r.name];d&&(s=!!d(e,r,t.warn)),s&&(l=!0,o+='{name:"'+r.name+'",rawName:"'+r.rawName+'"'+(r.value?",value:("+r.value+"),expression:"+JSON.stringify(r.value):"")+(r.arg?",arg:"+(r.isDynamicArg?r.arg:'"'+r.arg+'"'):"")+(r.modifiers?",modifiers:"+JSON.stringify(r.modifiers):"")+"},")}return l?o.slice(0,-1)+"]":void 0}}(e,t);a&&(n+=a+","),e.key&&(n+="key:"+e.key+","),e.ref&&(n+="ref:"+e.ref+","),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'+e.tag+'",');for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:"+so(e.attrs)+","),e.props&&(n+="domProps:"+so(e.props)+","),e.events&&(n+=Bs(e.events,!1)+","),e.nativeEvents&&(n+=Bs(e.nativeEvents,!0)+","),e.slotTarget&&!e.slotScope&&(n+="slot:"+e.slotTarget+","),e.scopedSlots&&(n+=function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||to(n)})),i=!!e.if;if(!a)for(var r=e.parent;r;){if(r.slotScope&&r.slotScope!==ms||r.for){a=!0;break}r.if&&(i=!0),r=r.parent}var s=Object.keys(t).map((function(e){return no(t[e],n)})).join(",");return"scopedSlots:_u(["+s+"]"+(a?",null,true":"")+(!a&&i?",null,false,"+function(e){for(var t=5381,n=e.length;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(s):"")+")"}(e,e.scopedSlots,t)+","),e.model&&(n+="model:{value:"+e.model.value+",callback:"+e.model.callback+",expression:"+e.model.expression+"},"),e.inlineTemplate){var r=function(e,t){var n=e.children[0];if(n&&1===n.type){var a=Gs(n,t.options);return"inlineTemplate:{render:function(){"+a.render+"},staticRenderFns:["+a.staticRenderFns.map((function(e){return"function(){"+e+"}"})).join(",")+"]}"}}(e,t);r&&(n+=r+",")}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b("+n+',"'+e.tag+'",'+so(e.dynamicAttrs)+")"),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function to(e){return 1===e.type&&("slot"===e.tag||e.children.some(to))}function no(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return Xs(e,t,no,"null");if(e.for&&!e.forProcessed)return Qs(e,t,no);var a=e.slotScope===ms?"":String(e.slotScope),i="function("+a+"){return "+("template"===e.tag?e.if&&n?"("+e.if+")?"+(ao(e,t)||"undefined")+":undefined":ao(e,t)||"undefined":Js(e,t))+"}",r=a?"":",proxy:true";return"{key:"+(e.slotTarget||'"default"')+",fn:"+i+r+"}"}function ao(e,t,n,a,i){var r=e.children;if(r.length){var s=r[0];if(1===r.length&&s.for&&"template"!==s.tag&&"slot"!==s.tag){var o=n?t.maybeComponent(s)?",1":",0":"";return""+(a||Js)(s,t)+o}var l=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var i=e[a];if(1===i.type){if(io(i)||i.ifConditions&&i.ifConditions.some((function(e){return io(e.block)}))){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(r,t.maybeComponent):0,d=i||ro;return"["+r.map((function(e){return d(e,t)})).join(",")+"]"+(l?","+l:"")}}function io(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function ro(e,t){return 1===e.type?Js(e,t):3===e.type&&e.isComment?function(e){return"_e("+JSON.stringify(e.text)+")"}(e):"_v("+(2===(n=e).type?n.expression:oo(JSON.stringify(n.text)))+")";var n}function so(e){for(var t="",n="",a=0;a<e.length;a++){var i=e[a],r=oo(i.value);i.dynamic?n+=i.name+","+r+",":t+='"'+i.name+'":'+r+","}return t="{"+t.slice(0,-1)+"}",n?"_d("+t+",["+n.slice(0,-1)+"])":t}function oo(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function lo(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),R}}function uo(e){var t=Object.create(null);return function(n,a,i){(a=A({},a)).warn,delete a.warn;var r=a.delimiters?String(a.delimiters)+n:n;if(t[r])return t[r];var s=e(n,a),o={},l=[];return o.render=lo(s.render,l),o.staticRenderFns=s.staticRenderFns.map((function(e){return lo(e,l)})),t[r]=o}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var po,co,yo=(po=function(e,t){var n=function(e,t){Gr=t.warn||$a,Yr=t.isPreTag||O,Qr=t.mustUseProp||O,es=t.getTagNamespace||O,t.isReservedTag,Kr=La(t.modules,"transformNode"),Zr=La(t.modules,"preTransformNode"),Xr=La(t.modules,"postTransformNode"),Jr=t.delimiters;var n,a,i=[],r=!1!==t.preserveWhitespace,s=t.whitespace,o=!1,l=!1;function d(e){if(u(e),o||e.processed||(e=hs(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&bs(n,{exp:e.elseif,block:e}),a&&!e.forbidden)if(e.elseif||e.else)s=e,d=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(a.children),d&&d.if&&bs(d,{exp:s.elseif,block:s});else{if(e.slotScope){var r=e.slotTarget||'"default"';(a.scopedSlots||(a.scopedSlots={}))[r]=e}a.children.push(e),e.parent=a}var s,d;e.children=e.children.filter((function(e){return!e.slotScope})),u(e),e.pre&&(o=!1),Yr(e.tag)&&(l=!1);for(var p=0;p<Xr.length;p++)Xr[p](e,t)}function u(e){if(!l)for(var t;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,i=[],r=t.expectHTML,s=t.isUnaryTag||O,o=t.canBeLeftOpenTag||O,l=0;e;){if(n=e,a&&Hr(a)){var d=0,u=a.toLowerCase(),p=jr[u]||(jr[u]=new RegExp("([\\s\\S]*?)(</"+u+"[^>]*>)","i")),c=e.replace(p,(function(e,n,a){return d=a.length,Hr(u)||"noscript"===u||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),qr(u,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""}));l+=e.length-c.length,e=c,x(u,l-d,l)}else{var y=e.indexOf("<");if(0===y){if(Dr.test(e)){var m=e.indexOf("--\x3e");if(m>=0){t.shouldKeepComment&&t.comment(e.substring(4,m),l,l+m+3),I(m+3);continue}}if(Vr.test(e)){var f=e.indexOf("]>");if(f>=0){I(f+2);continue}}var h=e.match(Fr);if(h){I(h[0].length);continue}var v=e.match(Lr);if(v){var b=l;I(v[0].length),x(v[1],b,l);continue}var g=C();if(g){_(g),qr(g.tagName,e)&&I(1);continue}}var T=void 0,w=void 0,k=void 0;if(y>=0){for(w=e.slice(y);!(Lr.test(w)||Pr.test(w)||Dr.test(w)||Vr.test(w)||(k=w.indexOf("<",1))<0);)y+=k,w=e.slice(y);T=e.substring(0,y)}y<0&&(T=e),T&&I(T.length),t.chars&&T&&t.chars(T,l-T.length,l)}if(e===n){t.chars&&t.chars(e);break}}function I(t){l+=t,e=e.substring(t)}function C(){var t=e.match(Pr);if(t){var n,a,i={tagName:t[1],attrs:[],start:l};for(I(t[0].length);!(n=e.match($r))&&(a=e.match(Or)||e.match(Rr));)a.start=l,I(a[0].length),a.end=l,i.attrs.push(a);if(n)return i.unarySlash=n[1],I(n[0].length),i.end=l,i}}function _(e){var n=e.tagName,l=e.unarySlash;r&&("p"===a&&Er(n)&&x(a),o(n)&&a===n&&x(n));for(var d=s(n)||!!l,u=e.attrs.length,p=new Array(u),c=0;c<u;c++){var y=e.attrs[c],m=y[3]||y[4]||y[5]||"",f="a"===n&&"href"===y[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;p[c]={name:y[1],value:Wr(m,f)}}d||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:p,start:e.start,end:e.end}),a=n),t.start&&t.start(n,p,d,e.start,e.end)}function x(e,n,r){var s,o;if(null==n&&(n=l),null==r&&(r=l),e)for(o=e.toLowerCase(),s=i.length-1;s>=0&&i[s].lowerCasedTag!==o;s--);else s=0;if(s>=0){for(var d=i.length-1;d>=s;d--)t.end&&t.end(i[d].tag,n,r);i.length=s,a=s&&i[s-1].tag}else"br"===o?t.start&&t.start(e,[],!0,n,r):"p"===o&&(t.start&&t.start(e,[],!1,n,r),t.end&&t.end(e,n,r))}x()}(e,{warn:Gr,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,r,s,u,p){var c=a&&a.ns||es(e);K&&"svg"===c&&(r=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];ks.test(a.name)||(a.name=a.name.replace(Is,""),t.push(a))}return t}(r));var y,m=fs(e,r,a);c&&(m.ns=c),"style"!==(y=m).tag&&("script"!==y.tag||y.attrsMap.type&&"text/javascript"!==y.attrsMap.type)||ae()||(m.forbidden=!0);for(var f=0;f<Zr.length;f++)m=Zr[f](m,t)||m;o||(function(e){null!=Ua(e,"v-pre")&&(e.pre=!0)}(m),m.pre&&(o=!0)),Yr(m.tag)&&(l=!0),o?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),i=0;i<n;i++)a[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(a[i].start=t[i].start,a[i].end=t[i].end);else e.pre||(e.plain=!0)}(m):m.processed||(vs(m),function(e){var t=Ua(e,"v-if");if(t)e.if=t,bs(e,{exp:t,block:e});else{null!=Ua(e,"v-else")&&(e.else=!0);var n=Ua(e,"v-else-if");n&&(e.elseif=n)}}(m),function(e){null!=Ua(e,"v-once")&&(e.once=!0)}(m)),n||(n=m),s?d(m):(a=m,i.push(m))},end:function(e,t,n){var r=i[i.length-1];i.length-=1,a=i[i.length-1],d(r)},chars:function(e,t,n){if(a&&(!K||"textarea"!==a.tag||a.attrsMap.placeholder!==e)){var i,d,u,p=a.children;(e=l||e.trim()?"script"===(i=a).tag||"style"===i.tag?e:ys(e):p.length?s?"condense"===s&&ps.test(e)?"":" ":r?" ":"":"")&&(l||"condense"!==s||(e=e.replace(cs," ")),!o&&" "!==e&&(d=function(e,t){var n=t?Ir(t):wr;if(n.test(e)){for(var a,i,r,s=[],o=[],l=n.lastIndex=0;a=n.exec(e);){(i=a.index)>l&&(o.push(r=e.slice(l,i)),s.push(JSON.stringify(r)));var d=Sa(a[1].trim());s.push("_s("+d+")"),o.push({"@binding":d}),l=i+a[0].length}return l<e.length&&(o.push(r=e.slice(l)),s.push(JSON.stringify(r))),{expression:s.join("+"),tokens:o}}}(e,Jr))?u={type:2,expression:d.expression,tokens:d.tokens,text:e}:" "===e&&p.length&&" "===p[p.length-1].text||(u={type:3,text:e}),u&&p.push(u))}},comment:function(e,t,n){if(a){var i={type:3,text:e,isComment:!0};a.children.push(i)}}}),n}(e.trim(),t);!1!==t.optimize&&Ss(n,t);var a=Gs(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),i=[],r=[];if(n)for(var s in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=A(Object.create(e.directives||null),n.directives)),n)"modules"!==s&&"directives"!==s&&(a[s]=n[s]);a.warn=function(e,t,n){(n?r:i).push(e)};var o=po(t.trim(),a);return o.errors=i,o.tips=r,o}return{compile:t,compileToFunctions:uo(t)}}),mo=yo(Os),fo=(mo.compile,mo.compileToFunctions);function ho(e){return(co=co||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',co.innerHTML.indexOf("&#10;")>0}var vo=!!q&&ho(!1),bo=!!q&&ho(!0),go=g((function(e){var t=ia(e);return t&&t.innerHTML})),To=Rn.prototype.$mount;Rn.prototype.$mount=function(e,t){if((e=e&&ia(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=go(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){var i=fo(a,{outputSourceRange:!1,shouldDecodeNewlines:vo,shouldDecodeNewlinesForHref:bo,delimiters:n.delimiters,comments:n.comments},this),r=i.render,s=i.staticRenderFns;n.render=r,n.staticRenderFns=s}}return To.call(this,e,t)},Rn.compile=fo;const wo=Rn;function ko(e,t){for(var n in t)e[n]=t[n];return e}var Io=/[!'()*]/g,Co=function(e){return"%"+e.charCodeAt(0).toString(16)},_o=/%2C/g,xo=function(e){return encodeURIComponent(e).replace(Io,Co).replace(_o,",")};function Ao(e){try{return decodeURIComponent(e)}catch(e){}return e}var Eo=function(e){return null==e||"object"==typeof e?e:String(e)};function Ro(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=Ao(n.shift()),i=n.length>0?Ao(n.join("=")):null;void 0===t[a]?t[a]=i:Array.isArray(t[a])?t[a].push(i):t[a]=[t[a],i]})),t):t}function Oo(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return xo(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(xo(t)):a.push(xo(t)+"="+xo(e)))})),a.join("&")}return xo(t)+"="+xo(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var Mo=/\/?$/;function So(e,t,n,a){var i=a&&a.options.stringifyQuery,r=t.query||{};try{r=Po(r)}catch(e){}var s={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:r,params:t.params||{},fullPath:Fo(t,i),matched:e?Lo(e):[]};return n&&(s.redirectedFrom=Fo(n,i)),Object.freeze(s)}function Po(e){if(Array.isArray(e))return e.map(Po);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=Po(e[n]);return t}return e}var $o=So(null,{path:"/"});function Lo(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function Fo(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var i=e.hash;return void 0===i&&(i=""),(n||"/")+(t||Oo)(a)+i}function Do(e,t,n){return t===$o?e===t:!!t&&(e.path&&t.path?e.path.replace(Mo,"")===t.path.replace(Mo,"")&&(n||e.hash===t.hash&&Vo(e.query,t.query)):!(!e.name||!t.name)&&e.name===t.name&&(n||e.hash===t.hash&&Vo(e.query,t.query)&&Vo(e.params,t.params)))}function Vo(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,i){var r=e[n];if(a[i]!==n)return!1;var s=t[n];return null==r||null==s?r===s:"object"==typeof r&&"object"==typeof s?Vo(r,s):String(r)===String(s)}))}function Ho(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var i=n.instances[a],r=n.enteredCbs[a];if(i&&r){delete n.enteredCbs[a];for(var s=0;s<r.length;s++)i._isBeingDestroyed||r[s](i)}}}}var jo={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,i=t.parent,r=t.data;r.routerView=!0;for(var s=i.$createElement,o=n.name,l=i.$route,d=i._routerViewCache||(i._routerViewCache={}),u=0,p=!1;i&&i._routerRoot!==i;){var c=i.$vnode?i.$vnode.data:{};c.routerView&&u++,c.keepAlive&&i._directInactive&&i._inactive&&(p=!0),i=i.$parent}if(r.routerViewDepth=u,p){var y=d[o],m=y&&y.component;return m?(y.configProps&&No(m,r,y.route,y.configProps),s(m,r,a)):s()}var f=l.matched[u],h=f&&f.components[o];if(!f||!h)return d[o]=null,s();d[o]={component:h},r.registerRouteInstance=function(e,t){var n=f.instances[o];(t&&n!==e||!t&&n===e)&&(f.instances[o]=t)},(r.hook||(r.hook={})).prepatch=function(e,t){f.instances[o]=t.componentInstance},r.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==f.instances[o]&&(f.instances[o]=e.componentInstance),Ho(l)};var v=f.props&&f.props[o];return v&&(ko(d[o],{route:l,configProps:v}),No(h,r,l,v)),s(h,r,a)}};function No(e,t,n,a){var i=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0}}(n,a);if(i){i=t.props=ko({},i);var r=t.attrs=t.attrs||{};for(var s in i)e.props&&s in e.props||(r[s]=i[s],delete i[s])}}function Bo(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var i=t.split("/");n&&i[i.length-1]||i.pop();for(var r=e.replace(/^\//,"").split("/"),s=0;s<r.length;s++){var o=r[s];".."===o?i.pop():"."!==o&&i.push(o)}return""!==i[0]&&i.unshift(""),i.join("/")}function Uo(e){return e.replace(/\/(?:\s*\/)+/g,"/")}var zo=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},qo=function e(t,n,a){return zo(n)||(a=n||a,n=[]),a=a||{},t instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return nl(e,t)}(t,n):zo(t)?function(t,n,a){for(var i=[],r=0;r<t.length;r++)i.push(e(t[r],n,a).source);return nl(new RegExp("(?:"+i.join("|")+")",al(a)),n)}(t,n,a):function(e,t,n){return il(Zo(e,n),t,n)}(t,n,a)},Wo=Zo,Go=Qo,Jo=il,Ko=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Zo(e,t){for(var n,a=[],i=0,r=0,s="",o=t&&t.delimiter||"/";null!=(n=Ko.exec(e));){var l=n[0],d=n[1],u=n.index;if(s+=e.slice(r,u),r=u+l.length,d)s+=d[1];else{var p=e[r],c=n[2],y=n[3],m=n[4],f=n[5],h=n[6],v=n[7];s&&(a.push(s),s="");var b=null!=c&&null!=p&&p!==c,g="+"===h||"*"===h,T="?"===h||"*"===h,w=n[2]||o,k=m||f;a.push({name:y||i++,prefix:c||"",delimiter:w,optional:T,repeat:g,partial:b,asterisk:!!v,pattern:k?tl(k):v?".*":"[^"+el(w)+"]+?"})}}return r<e.length&&(s+=e.substr(r)),s&&a.push(s),a}function Xo(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function Yo(e){return encodeURI(e).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function Qo(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",al(t)));return function(t,a){for(var i="",r=t||{},s=(a||{}).pretty?Xo:encodeURIComponent,o=0;o<e.length;o++){var l=e[o];if("string"!=typeof l){var d,u=r[l.name];if(null==u){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(zo(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var p=0;p<u.length;p++){if(d=s(u[p]),!n[o].test(d))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(d)+"`");i+=(0===p?l.prefix:l.delimiter)+d}}else{if(d=l.asterisk?Yo(u):s(u),!n[o].test(d))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+d+'"');i+=l.prefix+d}}else i+=l}return i}}function el(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function tl(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function nl(e,t){return e.keys=t,e}function al(e){return e&&e.sensitive?"":"i"}function il(e,t,n){zo(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,i=!1!==n.end,r="",s=0;s<e.length;s++){var o=e[s];if("string"==typeof o)r+=el(o);else{var l=el(o.prefix),d="(?:"+o.pattern+")";t.push(o),o.repeat&&(d+="(?:"+l+d+")*"),r+=d=o.optional?o.partial?l+"("+d+")?":"(?:"+l+"("+d+"))?":l+"("+d+")"}}var u=el(n.delimiter||"/"),p=r.slice(-u.length)===u;return a||(r=(p?r.slice(0,-u.length):r)+"(?:"+u+"(?=$))?"),r+=i?"$":a&&p?"":"(?="+u+"|$)",nl(new RegExp("^"+r,al(n)),t)}qo.parse=Wo,qo.compile=function(e,t){return Qo(Zo(e,t),t)},qo.tokensToFunction=Go,qo.tokensToRegExp=Jo;var rl=Object.create(null);function sl(e,t,n){t=t||{};try{var a=rl[e]||(rl[e]=qo.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function ol(e,t,n,a){var i="string"==typeof e?{path:e}:e;if(i._normalized)return i;if(i.name){var r=(i=ko({},e)).params;return r&&"object"==typeof r&&(i.params=ko({},r)),i}if(!i.path&&i.params&&t){(i=ko({},i))._normalized=!0;var s=ko(ko({},t.params),i.params);if(t.name)i.name=t.name,i.params=s;else if(t.matched.length){var o=t.matched[t.matched.length-1].path;i.path=sl(o,s,t.path)}return i}var l=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var i=e.indexOf("?");return i>=0&&(n=e.slice(i+1),e=e.slice(0,i)),{path:e,query:n,hash:t}}(i.path||""),d=t&&t.path||"/",u=l.path?Bo(l.path,d,n||i.append):d,p=function(e,t,n){void 0===t&&(t={});var a,i=n||Ro;try{a=i(e||"")}catch(e){a={}}for(var r in t){var s=t[r];a[r]=Array.isArray(s)?s.map(Eo):Eo(s)}return a}(l.query,i.query,a&&a.options.parseQuery),c=i.hash||l.hash;return c&&"#"!==c.charAt(0)&&(c="#"+c),{_normalized:!0,path:u,query:p,hash:c}}var ll,dl=function(){},ul={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,i=n.resolve(this.to,a,this.append),r=i.location,s=i.route,o=i.href,l={},d=n.options.linkActiveClass,u=n.options.linkExactActiveClass,p=null==d?"router-link-active":d,c=null==u?"router-link-exact-active":u,y=null==this.activeClass?p:this.activeClass,m=null==this.exactActiveClass?c:this.exactActiveClass,f=s.redirectedFrom?So(null,ol(s.redirectedFrom),null,n):s;l[m]=Do(a,f,this.exactPath),l[y]=this.exact||this.exactPath?l[m]:function(e,t){return 0===e.path.replace(Mo,"/").indexOf(t.path.replace(Mo,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,f);var h=l[m]?this.ariaCurrentValue:null,v=function(e){pl(e)&&(t.replace?n.replace(r,dl):n.push(r,dl))},b={click:pl};Array.isArray(this.event)?this.event.forEach((function(e){b[e]=v})):b[this.event]=v;var g={class:l},T=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:s,navigate:v,isActive:l[y],isExactActive:l[m]});if(T){if(1===T.length)return T[0];if(T.length>1||!T.length)return 0===T.length?e():e("span",{},T)}if("a"===this.tag)g.on=b,g.attrs={href:o,"aria-current":h};else{var w=cl(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=ko({},w.data);for(var I in k.on=k.on||{},k.on){var C=k.on[I];I in b&&(k.on[I]=Array.isArray(C)?C:[C])}for(var _ in b)_ in k.on?k.on[_].push(b[_]):k.on[_]=v;var x=w.data.attrs=ko({},w.data.attrs);x.href=o,x["aria-current"]=h}else g.on=b}return e(this.tag,g,this.$slots.default)}};function pl(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function cl(e){if(e)for(var t,n=0;n<e.length;n++){if("a"===(t=e[n]).tag)return t;if(t.children&&(t=cl(t.children)))return t}}var yl="undefined"!=typeof window;function ml(e,t,n,a,i){var r=t||[],s=n||Object.create(null),o=a||Object.create(null);e.forEach((function(e){fl(r,s,o,e,i)}));for(var l=0,d=r.length;l<d;l++)"*"===r[l]&&(r.push(r.splice(l,1)[0]),d--,l--);return{pathList:r,pathMap:s,nameMap:o}}function fl(e,t,n,a,i,r){var s=a.path,o=a.name,l=a.pathToRegexpOptions||{},d=function(e,t,n){return n||(e=e.replace(/\/$/,"")),"/"===e[0]||null==t?e:Uo(t.path+"/"+e)}(s,i,l.strict);"boolean"==typeof a.caseSensitive&&(l.sensitive=a.caseSensitive);var u={path:d,regex:hl(d,l),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:o,parent:i,matchAs:r,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};if(a.children&&a.children.forEach((function(a){var i=r?Uo(r+"/"+a.path):void 0;fl(e,t,n,a,u,i)})),t[u.path]||(e.push(u.path),t[u.path]=u),void 0!==a.alias)for(var p=Array.isArray(a.alias)?a.alias:[a.alias],c=0;c<p.length;++c){var y={path:p[c],children:a.children};fl(e,t,n,y,i,u.path||"/")}o&&(n[o]||(n[o]=u))}function hl(e,t){return qo(e,[],t)}function vl(e,t){var n=ml(e),a=n.pathList,i=n.pathMap,r=n.nameMap;function s(e,n,s){var l=ol(e,n,!1,t),d=l.name;if(d){var u=r[d];if(!u)return o(null,l);var p=u.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof l.params&&(l.params={}),n&&"object"==typeof n.params)for(var c in n.params)!(c in l.params)&&p.indexOf(c)>-1&&(l.params[c]=n.params[c]);return l.path=sl(u.path,l.params),o(u,l,s)}if(l.path){l.params={};for(var y=0;y<a.length;y++){var m=a[y],f=i[m];if(bl(f.regex,l.path,l.params))return o(f,l,s)}}return o(null,l)}function o(e,n,a){return e&&e.redirect?function(e,n){var a=e.redirect,i="function"==typeof a?a(So(e,n,null,t)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return o(null,n);var l=i,d=l.name,u=l.path,p=n.query,c=n.hash,y=n.params;if(p=l.hasOwnProperty("query")?l.query:p,c=l.hasOwnProperty("hash")?l.hash:c,y=l.hasOwnProperty("params")?l.params:y,d)return r[d],s({_normalized:!0,name:d,query:p,hash:c,params:y},void 0,n);if(u){var m=function(e,t){return Bo(e,t.parent?t.parent.path:"/",!0)}(u,e);return s({_normalized:!0,path:sl(m,y),query:p,hash:c},void 0,n)}return o(null,n)}(e,a||n):e&&e.matchAs?function(e,t,n){var a=s({_normalized:!0,path:sl(n,t.params)});if(a){var i=a.matched,r=i[i.length-1];return t.params=a.params,o(r,t)}return o(null,t)}(0,n,e.matchAs):So(e,n,a,t)}return{match:s,addRoute:function(e,t){var n="object"!=typeof e?r[e]:void 0;ml([t||e],a,i,r,n),n&&n.alias.length&&ml(n.alias.map((function(e){return{path:e,children:[t]}})),a,i,r,n)},getRoutes:function(){return a.map((function(e){return i[e]}))},addRoutes:function(e){ml(e,a,i,r)}}}function bl(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var i=1,r=a.length;i<r;++i){var s=e.keys[i-1];s&&(n[s.name||"pathMatch"]="string"==typeof a[i]?Ao(a[i]):a[i])}return!0}var gl=yl&&window.performance&&window.performance.now?window.performance:Date;function Tl(){return gl.now().toFixed(3)}var wl=Tl();function kl(){return wl}function Il(e){return wl=e}var Cl=Object.create(null);function _l(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=ko({},window.history.state);return n.key=kl(),window.history.replaceState(n,"",t),window.addEventListener("popstate",El),function(){window.removeEventListener("popstate",El)}}function xl(e,t,n,a){if(e.app){var i=e.options.scrollBehavior;i&&e.app.$nextTick((function(){var r=function(){var e=kl();if(e)return Cl[e]}(),s=i.call(e,t,n,a?r:null);s&&("function"==typeof s.then?s.then((function(e){Pl(e,r)})).catch((function(e){})):Pl(s,r))}))}}function Al(){var e=kl();e&&(Cl[e]={x:window.pageXOffset,y:window.pageYOffset})}function El(e){Al(),e.state&&e.state.key&&Il(e.state.key)}function Rl(e){return Ml(e.x)||Ml(e.y)}function Ol(e){return{x:Ml(e.x)?e.x:window.pageXOffset,y:Ml(e.y)?e.y:window.pageYOffset}}function Ml(e){return"number"==typeof e}var Sl=/^#\d/;function Pl(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var i=Sl.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(i){var r=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(i,r={x:Ml((n=r).x)?n.x:0,y:Ml(n.y)?n.y:0})}else Rl(e)&&(t=Ol(e))}else a&&Rl(e)&&(t=Ol(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var $l,Ll=yl&&(-1===($l=window.navigator.userAgent).indexOf("Android 2.")&&-1===$l.indexOf("Android 4.0")||-1===$l.indexOf("Mobile Safari")||-1!==$l.indexOf("Chrome")||-1!==$l.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState;function Fl(e,t){Al();var n=window.history;try{if(t){var a=ko({},n.state);a.key=kl(),n.replaceState(a,"",e)}else n.pushState({key:Il(Tl())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function Dl(e){Fl(e,!0)}function Vl(e,t,n){var a=function(i){i>=e.length?n():e[i]?t(e[i],(function(){a(i+1)})):a(i+1)};a(0)}var Hl={redirected:2,aborted:4,cancelled:8,duplicated:16};function jl(e,t){return Nl(e,t,Hl.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function Nl(e,t,n,a){var i=new Error(a);return i._isRouter=!0,i.from=e,i.to=t,i.type=n,i}var Bl=["params","query","hash"];function Ul(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function zl(e,t){return Ul(e)&&e._isRouter&&(null==t||e.type===t)}function ql(e,t){return Wl(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function Wl(e){return Array.prototype.concat.apply([],e)}var Gl="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Jl(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var Kl=function(e,t){this.router=e,this.base=function(e){if(!e)if(yl){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";return"/"!==e.charAt(0)&&(e="/"+e),e.replace(/\/$/,"")}(t),this.current=$o,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Zl(e,t,n,a){var i=ql(e,(function(e,a,i,r){var s=function(e,t){return"function"!=typeof e&&(e=ll.extend(e)),e.options[t]}(e,t);if(s)return Array.isArray(s)?s.map((function(e){return n(e,a,i,r)})):n(s,a,i,r)}));return Wl(a?i.reverse():i)}function Xl(e,t){if(t)return function(){return e.apply(t,arguments)}}Kl.prototype.listen=function(e){this.cb=e},Kl.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},Kl.prototype.onError=function(e){this.errorCbs.push(e)},Kl.prototype.transitionTo=function(e,t,n){var a,i=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var r=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),t&&t(a),i.ensureURL(),i.router.afterHooks.forEach((function(e){e&&e(a,r)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!i.ready&&(zl(e,Hl.redirected)&&r===$o||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(e)}))))}))},Kl.prototype.confirmTransition=function(e,t,n){var a=this,i=this.current;this.pending=e;var r,s,o=function(e){!zl(e)&&Ul(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},l=e.matched.length-1,d=i.matched.length-1;if(Do(e,i)&&l===d&&e.matched[l]===i.matched[d])return this.ensureURL(),e.hash&&xl(this.router,i,e,!1),o(((s=Nl(r=i,e,Hl.duplicated,'Avoided redundant navigation to current location: "'+r.fullPath+'".')).name="NavigationDuplicated",s));var u,p=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),c=p.updated,y=p.deactivated,m=p.activated,f=[].concat(function(e){return Zl(e,"beforeRouteLeave",Xl,!0)}(y),this.router.beforeHooks,function(e){return Zl(e,"beforeRouteUpdate",Xl)}(c),m.map((function(e){return e.beforeEnter})),(u=m,function(e,t,n){var a=!1,i=0,r=null;ql(u,(function(e,t,s,o){if("function"==typeof e&&void 0===e.cid){a=!0,i++;var l,d=Jl((function(t){var a;((a=t).__esModule||Gl&&"Module"===a[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:ll.extend(t),s.components[o]=t,--i<=0&&n()})),u=Jl((function(e){var t="Failed to resolve async component "+o+": "+e;r||(r=Ul(e)?e:new Error(t),n(r))}));try{l=e(d,u)}catch(e){u(e)}if(l)if("function"==typeof l.then)l.then(d,u);else{var p=l.component;p&&"function"==typeof p.then&&p.then(d,u)}}})),a||n()})),h=function(t,n){if(a.pending!==e)return o(jl(i,e));try{t(e,i,(function(t){!1===t?(a.ensureURL(!0),o(function(e,t){return Nl(e,t,Hl.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,e))):Ul(t)?(a.ensureURL(!0),o(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(o(function(e,t){return Nl(e,t,Hl.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return Bl.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}(i,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){o(e)}};Vl(f,h,(function(){var n=function(e){return Zl(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,i,r){return e(a,i,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),r(e)}))}}(e,n,a)}))}(m);Vl(n.concat(a.router.resolveHooks),h,(function(){if(a.pending!==e)return o(jl(i,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){Ho(e)}))}))}))},Kl.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},Kl.prototype.setupListeners=function(){},Kl.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=$o,this.pending=null};var Yl=function(e){function t(t,n){e.call(this,t,n),this._startLocation=Ql(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=Ll&&n;a&&this.listeners.push(_l());var i=function(){var n=e.current,i=Ql(e.base);e.current===$o&&i===e._startLocation||e.transitionTo(i,(function(e){a&&xl(t,e,n,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Fl(Uo(a.base+e.fullPath)),xl(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Dl(Uo(a.base+e.fullPath)),xl(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(Ql(this.base)!==this.current.fullPath){var t=Uo(this.base+this.current.fullPath);e?Fl(t):Dl(t)}},t.prototype.getCurrentLocation=function(){return Ql(this.base)},t}(Kl);function Ql(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf(Uo(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var ed=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=Ql(e);if(!/^\/#/.test(t))return window.location.replace(Uo(e+"/#"+t)),!0}(this.base)||td()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=Ll&&t;n&&this.listeners.push(_l());var a=function(){var t=e.current;td()&&e.transitionTo(nd(),(function(a){n&&xl(e.router,a,t,!0),Ll||rd(a.fullPath)}))},i=Ll?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){id(e.fullPath),xl(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){rd(e.fullPath),xl(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;nd()!==t&&(e?id(t):rd(t))},t.prototype.getCurrentLocation=function(){return nd()},t}(Kl);function td(){var e=nd();return"/"===e.charAt(0)||(rd("/"+e),!1)}function nd(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function ad(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function id(e){Ll?Fl(ad(e)):window.location.hash=e}function rd(e){Ll?Dl(ad(e)):window.location.replace(ad(e))}var sd=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){zl(e,Hl.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(Kl),od=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=vl(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!Ll&&!1!==e.fallback,this.fallback&&(t="hash"),yl||(t="abstract"),this.mode=t,t){case"history":this.history=new Yl(this,e.base);break;case"hash":this.history=new ed(this,e.base,this.fallback);break;case"abstract":this.history=new sd(this,e.base)}},ld={currentRoute:{configurable:!0}};function dd(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}od.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},ld.currentRoute.get=function(){return this.history&&this.history.current},od.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof Yl||n instanceof ed){var a=function(e){n.setupListeners(),function(e){var a=n.current,i=t.options.scrollBehavior;Ll&&i&&"fullPath"in e&&xl(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},od.prototype.beforeEach=function(e){return dd(this.beforeHooks,e)},od.prototype.beforeResolve=function(e){return dd(this.resolveHooks,e)},od.prototype.afterEach=function(e){return dd(this.afterHooks,e)},od.prototype.onReady=function(e,t){this.history.onReady(e,t)},od.prototype.onError=function(e){this.history.onError(e)},od.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},od.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},od.prototype.go=function(e){this.history.go(e)},od.prototype.back=function(){this.go(-1)},od.prototype.forward=function(){this.go(1)},od.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},od.prototype.resolve=function(e,t,n){var a=ol(e,t=t||this.history.current,n,this),i=this.match(a,t),r=i.redirectedFrom||i.fullPath,s=function(e,t,n){var a="hash"===n?"#"+t:t;return e?Uo(e+"/"+a):a}(this.history.base,r,this.mode);return{location:a,route:i,href:s,normalizedTo:a,resolved:i}},od.prototype.getRoutes=function(){return this.matcher.getRoutes()},od.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==$o&&this.history.transitionTo(this.history.getCurrentLocation())},od.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==$o&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(od.prototype,ld),od.install=function e(t){if(!e.installed||ll!==t){e.installed=!0,ll=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",jo),t.component("RouterLink",ul);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},od.version="3.5.4",od.isNavigationFailure=zl,od.NavigationFailureType=Hl,od.START_LOCATION=$o,yl&&window.Vue&&window.Vue.use(od);const ud=od;var pd=function(){var e=this.$createElement,t=this._self._c||e;return t("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[t("router-view")],1)};function cd(e,t,n,a,i,r,s,o){var l,d="function"==typeof e?e.options:e;if(t&&(d.render=t,d.staticRenderFns=n,d._compiled=!0),a&&(d.functional=!0),r&&(d._scopeId="data-v-"+r),s?(l=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),i&&i.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(s)},d._ssrRegister=l):i&&(l=o?function(){i.call(this,(d.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(d.functional){d._injectStyles=l;var u=d.render;d.render=function(e,t){return l.call(t),u(e,t)}}else{var p=d.beforeCreate;d.beforeCreate=p?[].concat(p,l):[l]}return{exports:e,options:d}}pd._withStripped=!0,n(387);var yd=cd({},pd,[],!1,null,null,null);yd.options.__file="node_modules/hardhat-docgen/src/App.vue";const md=yd.exports;var fd=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[n("HeaderBar"),e._v(" "),n("div",{staticClass:"pb-32"},[n("div",{staticClass:"space-y-4"},[n("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),n("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),n("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),n("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),n("p",[e._v(e._s(e.json.notice))]),e._v(" "),n("p",[e._v(e._s(e.json.details))])]),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?n("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.receive?n("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),n("div",{staticClass:"mt-8"},[e.json.fallback?n("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?n("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?n("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?n("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),n("FooterBar")],1)};fd._withStripped=!0;var hd=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[n("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[n("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};hd._withStripped=!0;const vd=JSON.parse('{"u2":"hardhat-docgen","cj":"https://github.com/ItsNickBarry/hardhat-docgen"}');var bd=cd({data:function(){return{repository:vd.cj,name:vd.u2}},methods:{openLink(e){window.open(e,"_blank")}}},hd,[],!1,null,null,null);bd.options.__file="node_modules/hardhat-docgen/src/components/FooterBar.vue";const gd=bd.exports;var Td=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[n("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[e._v("\n    <- Go back\n  ")])],1)};Td._withStripped=!0;var wd=cd({},Td,[],!1,null,null,null);wd.options.__file="node_modules/hardhat-docgen/src/components/HeaderBar.vue";const kd=wd.exports;var Id=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[n("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),n("div",{staticClass:"space-y-3"},[n("p",[e._v(e._s(e.json.notice))]),e._v(" "),n("p",[e._v(e._s(e.json.details))]),e._v(" "),n("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),n("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};Id._withStripped=!0;var Cd=function(){var e=this,t=e.$createElement,n=e._self._c||t;return e.items.length>0?n("ul",[n("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(t,a){return n("li",{key:a},[n("span",{staticClass:"bg-gray-300"},[e._v(e._s(t.type))]),e._v(" "),n("b",[e._v(e._s(t.name||"_"+a))]),t.desc?n("span",[e._v(": "),n("i",[e._v(e._s(t.desc))])]):e._e()])}))],2):e._e()};Cd._withStripped=!0;var _d=cd({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},Cd,[],!1,null,null,null);_d.options.__file="node_modules/hardhat-docgen/src/components/MemberSection.vue";const xd={components:{MemberSection:_d.exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map((e=>({...e,desc:this.params[e.name]})))},inputSignature:function(){return`(${this.inputs.map((e=>e.type)).join(",")})`},outputs:function(){return(this.json.outputs||[]).map(((e,t)=>({...e,desc:this.returns[e.name||`_${t}`]})))},outputSignature:function(){return`(${this.outputs.map((e=>e.type)).join(",")})`}}};var Ad=cd(xd,Id,[],!1,null,null,null);Ad.options.__file="node_modules/hardhat-docgen/src/components/Member.vue";const Ed=Ad.exports;var Rd=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full mt-8"},[n("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(t){return n("Member",{key:t,staticClass:"mt-3",attrs:{json:e.json[t]}})}))],2)};Rd._withStripped=!0;var Od=cd({components:{Member:Ed},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},Rd,[],!1,null,null,null);Od.options.__file="node_modules/hardhat-docgen/src/components/MemberSet.vue";var Md=cd({components:{Member:Ed,MemberSet:Od.exports,HeaderBar:kd,FooterBar:gd},props:{json:{type:Object,default:()=>new Object}}},fd,[],!1,null,null,null);Md.options.__file="node_modules/hardhat-docgen/src/components/Contract.vue";const Sd=Md.exports;var Pd=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[n("Branch",{attrs:{json:e.trees,name:"Sources:"}}),e._v(" "),n("FooterBar",{staticClass:"mt-20"})],1)};Pd._withStripped=!0;var $d=function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?n("div",{staticClass:"pl-5"},e._l(e.json,(function(t,a){return n("div",{key:a},[n("router-link",{attrs:{to:t.source+":"+t.name}},[e._v("\n        "+e._s(t.name)+"\n      ")])],1)})),0):n("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(t){return n("div",{key:t},[n("Branch",{attrs:{json:e.json[t],name:t}})],1)})),0)])};$d._withStripped=!0;var Ld=cd({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},$d,[],!1,null,null,null);Ld.options.__file="node_modules/hardhat-docgen/src/components/Branch.vue";var Fd=cd({components:{Branch:Ld.exports,FooterBar:gd},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.replace("/","//").split(/\/(?=[^\/])/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},Pd,[],!1,null,null,null);Fd.options.__file="node_modules/hardhat-docgen/src/components/Index.vue";const Dd=Fd.exports;wo.use(ud);const Vd={"src/HookBeaconProxy.sol:HookBeaconProxy":{source:"src/HookBeaconProxy.sol",name:"HookBeaconProxy",title:"HookBeaconProxy a proxy contract that points to an implementation provided by a Beacon",details:"This contract implements a proxy that gets the implementation address for each call from a {UpgradeableBeacon}. The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't conflict with the storage layout of the implementation behind the proxy. This is an extension of the OpenZeppelin beacon proxy, however differs in that it is initializeable, which means it is usable with Create2.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},events:{"AdminChanged(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"previousAdmin",type:"address"},{indexed:!1,internalType:"address",name:"newAdmin",type:"address"}],name:"AdminChanged",type:"event"},"BeaconUpgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beacon",type:"address"}],name:"BeaconUpgraded",type:"event"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event"}},methods:{"initializeBeacon(address,bytes)":{inputs:[{internalType:"address",name:"beacon",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"initializeBeacon",outputs:[],stateMutability:"nonpayable",type:"function",details:"Initializes the proxy with `beacon`. If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity constructor. Requirements: - `beacon` must be a contract with the interface {IBeacon}."}}},"src/HookBidPool.sol:HookBidPool":{source:"src/HookBidPool.sol",name:"HookBidPool",title:"HookBidPool",author:"Jake Nyquist-j@hook.xyz",details:"This contract is directly interacted with by users, and holds approvals for ERC-20 tokens. In order for an order to be filled, it must be signed by the maker and the maker must have enough balance to provide the order proceeds and relevant fees. The maximum bid the order maker has offered is computed using the volatility and risk-free rate signed into the order. This information is combined with the NFT floor price provided by the off-chain oracle to compute the maximum bid price. If the amount of consideration requested by the seller + the protocol fees is less than the maximum bid, the order can then be filled. The seller will receive their requested proceeds, the protocol will receive their fees, and the buyer receives their option nft. The order must also be signed by the off-chain order validity oracle. This oracle is responsible for allowing the user to make gasless cancellations which take effect as soon as the last outstanding order validity signature expires. Alternatively, the user can make a calculation directly on the contract with their order hash to immediately cancel their order.",notice:"HookBidPools allows users to make off-chain orders in terms of an implied volatility which can later be filled by an option seller. The price of the sell will be computed using the Black-Scholes model at bid time.",constructor:{inputs:[{internalType:"address",name:"_weth",type:"address"},{internalType:"address",name:"_initialAdmin",type:"address"},{internalType:"address",name:"_priceOracleSigner",type:"address"},{internalType:"address",name:"_orderValidityOracleSigner",type:"address"},{internalType:"uint64",name:"_feeBips",type:"uint64"},{internalType:"address",name:"_feeRecipient",type:"address"},{internalType:"address",name:"_protocol",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"FeesUpdated(uint64)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint64",name:"feeBips",type:"uint64"}],name:"FeesUpdated",type:"event",params:{feeBips:"the new fee take rate in bips"},notice:"event emitted when the fee take rate is updated"},"OrderCancelled(address,bytes32)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"maker",type:"address"},{indexed:!1,internalType:"bytes32",name:"orderHash",type:"bytes32"}],name:"OrderCancelled",type:"event",params:{maker:"the signer who made the order initially",orderHash:"the eip-712 hash of the order"},notice:"event emitted when an order is canceled"},"OrderFilled(address,address,bytes32,uint256,uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"maker",type:"address"},{indexed:!1,internalType:"address",name:"taker",type:"address"},{indexed:!1,internalType:"bytes32",name:"orderHash",type:"bytes32"},{indexed:!1,internalType:"uint256",name:"proceeds",type:"uint256"},{indexed:!1,internalType:"uint256",name:"fees",type:"uint256"},{indexed:!1,internalType:"address",name:"optionContract",type:"address"},{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"}],name:"OrderFilled",type:"event",params:{fees:"the fees the buyer paid, in addition to the proceeds to the sellers",maker:"the signer who made the order initially",optionContract:"the contract address of the Hook option instrument",optionId:"the id of the option within the optionContract",orderHash:"the eip-712 hash of the order",proceeds:"the proceeds the seller receives",taker:"the caller who filled the order"},notice:"event emitted when an option is sold"},"OrderValidityOracleSignerUpdated(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oracle",type:"address"}],name:"OrderValidityOracleSignerUpdated",type:"event",params:{oracle:"the new order validity oracle"},notice:"event emitted when the order validity oracle is updated"},"PauseUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"newState",type:"bool"}],name:"PauseUpdated",type:"event",params:{newState:"the new paused state of the contract"},notice:"event emitted when the paused state of the contract changes\\"},"PriceOracleSignerUpdated(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"oracle",type:"address"}],name:"PriceOracleSignerUpdated",type:"event",params:{oracle:"the new oracle address"},notice:"event emitted when the oracle address is updated"},"ProtocolAddressSet(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"protocol",type:"address"}],name:"ProtocolAddressSet",type:"event",params:{protocol:"the new protocol address"},notice:"event emitted when the protocol address is updated"},"ProtocolFeeRecipientUpdated(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"recipient",type:"address"}],name:"ProtocolFeeRecipientUpdated",type:"event",params:{recipient:"the new protocol fee recipient"},notice:"event emitted when the protocol fee recipient is updated"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"}},methods:{"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"EIP712_DOMAIN_SEPARATOR()":{inputs:[],name:"EIP712_DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"FEES_ROLE()":{inputs:[],name:"FEES_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the role that can update the fee amount and recipient, should be held by a timelock"},"ORACLE_ROLE()":{inputs:[],name:"ORACLE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the role that can update the price oracle signer, should be held by a timelock If an oracle is compromised, the pool should be paused immediately, a new oracle nominated via the timelock, and the pool unpaused after the timelock delay has passed."},"PAUSER_ROLE()":{inputs:[],name:"PAUSER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the role that can pause the contract - should be held by a mulitsig"},"PROTOCOL_ROLE()":{inputs:[],name:"PROTOCOL_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the role that can update the protocol address - should be held by a multisig"},"cancelOrder((uint8,address,uint256,uint256,uint8,uint8,uint256,uint64,uint64,uint64,(address,bytes)[],address,uint64,uint256,uint64))":{inputs:[{components:[{internalType:"enum PoolOrders.OrderDirection",name:"direction",type:"uint8"},{internalType:"address",name:"maker",type:"address"},{internalType:"uint256",name:"orderExpiry",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint8",name:"size",type:"uint8"},{internalType:"enum PoolOrders.OptionType",name:"optionType",type:"uint8"},{internalType:"uint256",name:"maxStrikePriceMultiple",type:"uint256"},{internalType:"uint64",name:"minOptionDuration",type:"uint64"},{internalType:"uint64",name:"maxOptionDuration",type:"uint64"},{internalType:"uint64",name:"maxPriceSignalAge",type:"uint64"},{components:[{internalType:"contract IPropertyValidator",name:"propertyValidator",type:"address"},{internalType:"bytes",name:"propertyData",type:"bytes"}],internalType:"struct PoolOrders.Property[]",name:"nftProperties",type:"tuple[]"},{internalType:"address",name:"optionMarketAddress",type:"address"},{internalType:"uint64",name:"impliedVolBips",type:"uint64"},{internalType:"uint256",name:"skewDecimal",type:"uint256"},{internalType:"uint64",name:"riskFreeRateBips",type:"uint64"}],internalType:"struct PoolOrders.Order",name:"order",type:"tuple"}],name:"cancelOrder",outputs:[],stateMutability:"nonpayable",type:"function",details:"this function is available even when the pool is paused in case makers want to cancel orders as a result of the event that motivated the pause.",params:{order:"the order struct that should no longer be fillable."},notice:"Function to allow a maker to cancel all examples of an order that they've already signed. If an order has already been filled, but support more than one fill, calling this function cancels future fills of the order (but not current ones)."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"sellOption((uint8,address,uint256,uint256,uint8,uint8,uint256,uint64,uint64,uint64,(address,bytes)[],address,uint64,uint256,uint64),(uint8,uint8,bytes32,bytes32),(uint256,uint256,uint256,uint8,bytes32,bytes32),(bytes32,uint256,uint8,bytes32,bytes32),uint256,uint256)":{inputs:[{components:[{internalType:"enum PoolOrders.OrderDirection",name:"direction",type:"uint8"},{internalType:"address",name:"maker",type:"address"},{internalType:"uint256",name:"orderExpiry",type:"uint256"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint8",name:"size",type:"uint8"},{internalType:"enum PoolOrders.OptionType",name:"optionType",type:"uint8"},{internalType:"uint256",name:"maxStrikePriceMultiple",type:"uint256"},{internalType:"uint64",name:"minOptionDuration",type:"uint64"},{internalType:"uint64",name:"maxOptionDuration",type:"uint64"},{internalType:"uint64",name:"maxPriceSignalAge",type:"uint64"},{components:[{internalType:"contract IPropertyValidator",name:"propertyValidator",type:"address"},{internalType:"bytes",name:"propertyData",type:"bytes"}],internalType:"struct PoolOrders.Property[]",name:"nftProperties",type:"tuple[]"},{internalType:"address",name:"optionMarketAddress",type:"address"},{internalType:"uint64",name:"impliedVolBips",type:"uint64"},{internalType:"uint256",name:"skewDecimal",type:"uint256"},{internalType:"uint64",name:"riskFreeRateBips",type:"uint64"}],internalType:"struct PoolOrders.Order",name:"order",type:"tuple"},{components:[{internalType:"enum Signatures.SignatureType",name:"signatureType",type:"uint8"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],internalType:"struct Signatures.Signature",name:"orderSignature",type:"tuple"},{components:[{internalType:"uint256",name:"assetPriceInWei",type:"uint256"},{internalType:"uint256",name:"priceObservedTimestamp",type:"uint256"},{internalType:"uint256",name:"goodTilTimestamp",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],internalType:"struct HookBidPool.AssetPriceClaim",name:"assetPrice",type:"tuple"},{components:[{internalType:"bytes32",name:"orderHash",type:"bytes32"},{internalType:"uint256",name:"goodTilTimestamp",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],internalType:"struct HookBidPool.OrderValidityOracleClaim",name:"orderValidityOracleClaim",type:"tuple"},{internalType:"uint256",name:"saleProceeds",type:"uint256"},{internalType:"uint256",name:"optionId",type:"uint256"}],name:"sellOption",outputs:[],stateMutability:"nonpayable",type:"function",details:'the optionInstrumentAddress must be trusted by the orderer (maker) when signing to be related to their desired market / option terms (i.e. the option must be a european call option on the correct underlying asset). If the option instrument/market supports many different sub-collections, as in the case with artblocks or a foundation shared contract, then a corresponding property validator should be included in the order as to ensure that the underlying asset for the option is the one that the maker intended. The value of the "bid" for a specific order changes (decreases) with each block because the time until the option expires decreases. Instead of computing the highest possible sale proceeds at the time of the order, an implementer can compute a slightly lower sale proceeds, perhaps at a time a few blocks into the future, to ensure that the transaction is still successful. If they do this, the protocol won\'t earn extra fees -- that savings is passed on to the buyer.',params:{assetPrice:"the price of the underlying asset, signed off-chain by the oracle",optionId:"the id of the option token",order:"the order struct from the off-chain orderbook",orderSignature:"the signature of the order struct signed by the maker",orderValidityOracleClaim:"the claim that the order is still valid, signed off-chain by the oracle",saleProceeds:"the proceeds from the sale desired by the filler/caller, denominated in the quote asset"},notice:"sells a european call option to a bidder"},"setFeeBips(uint64)":{inputs:[{internalType:"uint64",name:"_feeBips",type:"uint64"}],name:"setFeeBips",outputs:[],stateMutability:"nonpayable",type:"function"},"setFeeRecipient(address)":{inputs:[{internalType:"address",name:"_feeRecipient",type:"address"}],name:"setFeeRecipient",outputs:[],stateMutability:"nonpayable",type:"function"},"setOrderValidityOracleSigner(address)":{inputs:[{internalType:"address",name:"_orderValidityOracleSigner",type:"address"}],name:"setOrderValidityOracleSigner",outputs:[],stateMutability:"nonpayable",type:"function"},"setPoolPaused(bool)":{inputs:[{internalType:"bool",name:"_paused",type:"bool"}],name:"setPoolPaused",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets a paused / unpaused state for this bid pool",params:{_paused:"should the bid pool be set to paused?"}},"setPriceOracleSigner(address)":{inputs:[{internalType:"address",name:"_priceOracleSigner",type:"address"}],name:"setPriceOracleSigner",outputs:[],stateMutability:"nonpayable",type:"function"},"setProtocol(address)":{inputs:[{internalType:"address",name:"_protocol",type:"address"}],name:"setProtocol",outputs:[],stateMutability:"nonpayable",type:"function",notice:"EXTERNAL ACCESS-CONTROLLED FUNCTIONS ///"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."}}},"src/HookCoveredCallFactory.sol:HookCoveredCallFactory":{source:"src/HookCoveredCallFactory.sol",name:"HookCoveredCallFactory",title:"Hook Covered Call Factory",author:"Jake Nyquist-j@hook.xyz",details:"See {IHookCoveredCallFactory}.The factory looks up certain roles by calling the {IHookProtocol} to verify",constructor:{inputs:[{internalType:"address",name:"hookProtocolAddress",type:"address"},{internalType:"address",name:"beaconAddress",type:"address"},{internalType:"address",name:"preApprovedMarketplace",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"CoveredCallInstrumentCreated(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"assetAddress",type:"address"},{indexed:!1,internalType:"address",name:"instrumentAddress",type:"address"}],name:"CoveredCallInstrumentCreated",type:"event"}},methods:{"ALLOWLISTER_ROLE()":{inputs:[],name:"ALLOWLISTER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the allowlister is able to enable and disable projects to mint instruments"},"CALL_UPGRADER()":{inputs:[],name:"CALL_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the call upgrader role is able to upgrade the implementation of the covered call options"},"COLLECTION_CONF()":{inputs:[],name:"COLLECTION_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the collection configuration role allows the actor to make changes the collection configs on the protocol contract"},"MARKET_CONF()":{inputs:[],name:"MARKET_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the market configuration role allows the actor to make changes to how the market operates"},"PAUSER_ROLE()":{inputs:[],name:"PAUSER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the pauser is able to start and pause various components of the protocol"},"VAULT_UPGRADER()":{inputs:[],name:"VAULT_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the vault upgrader role is able to upgrade the implementation for all vaults"},"getCallInstrument(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"getCallInstrument",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Registry of all of the active markets projects with supported call instruments"},"makeCallInstrument(address)":{inputs:[{internalType:"address",name:"assetAddress",type:"address"}],name:"makeCallInstrument",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",details:"See {IHookCoveredCallFactory-makeCallInstrument}.Only holders of the ALLOWLISTER_ROLE on the {IHookProtocol} can create these addresses."}}},"src/HookCoveredCallImplV1.sol:HookCoveredCallImplV1":{source:"src/HookCoveredCallImplV1.sol",name:"HookCoveredCallImplV1",title:"HookCoveredCallImplV1 an implementation of covered calls on Hook",author:"Jake Nyquist-j@hook.xyz",details:"In the context of a single call option, the role of the writer is non-transferrable.This contract is intended to be an implementation referenced by a proxy",notice:"See {IHookCoveredCall}.",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Bid(uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"bidAmount",type:"uint256"},{indexed:!1,internalType:"address",name:"bidder",type:"address"}],name:"Bid",type:"event",notice:"emitted when a call option settlement auction gets and accepts a new bid"},"CallCreated(address,address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"writer",type:"address"},{indexed:!1,internalType:"address",name:"vaultAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"assetId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"strikePrice",type:"uint256"},{indexed:!1,internalType:"uint256",name:"expiration",type:"uint256"}],name:"CallCreated",type:"event",notice:"emitted when a new call option is successfully minted with a specific underlying vault"},"CallProceedsDistributed(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"},{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"CallProceedsDistributed",type:"event",notice:"emitted when an option owner claims their proceeds"},"CallReclaimed(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"}],name:"CallReclaimed",type:"event",notice:"emitted when a call option is reclaimed"},"CallSettled(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"},{indexed:!1,internalType:"bool",name:"claimable",type:"bool"}],name:"CallSettled",type:"event",notice:"emitted when a call option is settled"},"ExpiredCallBurned(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"}],name:"ExpiredCallBurned",type:"event",notice:"emitted when a expired call option is burned"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event"},"MarketPauseUpdated(bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"bool",name:"paused",type:"bool"}],name:"MarketPauseUpdated",type:"event",details:"Emitted when the market is paused or unpaused",params:{paused:"true if paused false otherwise"}},"MinBidIncrementUpdated(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"bidIncrementBips",type:"uint256"}],name:"MinBidIncrementUpdated",type:"event",details:"Emitted when the bid increment is updated",params:{bidIncrementBips:"the new bid increment amount in bips"}},"MinOptionDurationUpdated(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"optionDuration",type:"uint256"}],name:"MinOptionDurationUpdated",type:"event",details:"emitted when the minimum duration for an option is changed",params:{optionDuration:"new minimum length of an option in seconds."}},"SettlementAuctionStartOffsetUpdated(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"startOffset",type:"uint256"}],name:"SettlementAuctionStartOffsetUpdated",type:"event",details:"emitted when the settlement auction start offset is updated",params:{startOffset:"new number of seconds from expiration when the start offset begins"}},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},stateVariables:{"allowedUnderlyingAddress()":{inputs:[],name:"allowedUnderlyingAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",details:"the address of the token contract permitted to serve as underlying assets for this instrument."},"marketPaused()":{inputs:[],name:"marketPaused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"stateVariable",details:"this is a flag that can be set to pause this particular instance of the call option contract. NOTE: settlement auctions are still enabled in this case because pausing the market should not change the financial situation for the holder of the options."},"minBidIncrementBips()":{inputs:[],name:"minBidIncrementBips",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"stateVariable",details:"this is the minimum amount of the current bid that the new bid must exceed the current bid by in order to be considered valid. This amount is expressed in basis points (i.e. 1/100th of 1%)"},"minimumOptionDuration()":{inputs:[],name:"minimumOptionDuration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"stateVariable",details:"this is the minimum duration of an option created in this contract instance"},"settlementAuctionStartOffset()":{inputs:[],name:"settlementAuctionStartOffset",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"stateVariable",details:"this is the amount of time before the expiration of the option that the settlement auction will begin."},"weth()":{inputs:[],name:"weth",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",details:"the address of WETH on the chain where this contract is deployed"}},methods:{"ALLOWLISTER_ROLE()":{inputs:[],name:"ALLOWLISTER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the allowlister is able to enable and disable projects to mint instruments"},"CALL_UPGRADER()":{inputs:[],name:"CALL_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the call upgrader role is able to upgrade the implementation of the covered call options"},"COLLECTION_CONF()":{inputs:[],name:"COLLECTION_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the collection configuration role allows the actor to make changes the collection configs on the protocol contract"},"MARKET_CONF()":{inputs:[],name:"MARKET_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the market configuration role allows the actor to make changes to how the market operates"},"PAUSER_ROLE()":{inputs:[],name:"PAUSER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the pauser is able to start and pause various components of the protocol"},"VAULT_UPGRADER()":{inputs:[],name:"VAULT_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the vault upgrader role is able to upgrade the implementation for all vaults"},"_preApprovedMarketplace()":{inputs:[],name:"_preApprovedMarketplace",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-approve}."},"assetOptions(address,uint32)":{inputs:[{internalType:"contract IHookVault",name:"",type:"address"},{internalType:"uint32",name:"",type:"uint32"}],name:"assetOptions",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721-balanceOf}."},"bid(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"bid",outputs:[],stateMutability:"payable",type:"function",details:"See {IHookCoveredCall-bid}."},"burn(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns `tokenId`. See {ERC721-_burn}. Requirements: - The caller must own `tokenId` or be an approved operator."},"burnExpiredOption(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"burnExpiredOption",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookCoveredCall-burnExpiredOption}."},"claimOptionProceeds(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"claimOptionProceeds",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookCoveredCall-claimOptionProceeds}"},"contractUri(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"contractUri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"this is the OpenSea compatible collection - level metadata URI."},"currentBid(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"currentBid",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function",details:"See {IHookCoveredCall-currentBid}."},"currentBidder(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"currentBidder",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IHookCoveredCall-currentBidder}."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-getApproved}."},"getAssetId(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getAssetId",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",details:"see {IHookCoveredCall-getAssetId}."},"getExpiration(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getExpiration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"see {IHookCoveredCall-getExpiration}."},"getOptionIdForAsset(address,uint32)":{inputs:[{internalType:"address",name:"vault",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getOptionIdForAsset",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"see {IHookCoveredCall-getOptionIdForAsset}"},"getStrikePrice(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getStrikePrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"see {IHookCoveredCall-getStrikePrice}."},"getTransferCount(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getTransferCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"this count can be used by overbooks to invalidate orders after a token has been transferred, preventing stale order execution by malicious parties",notice:"the number of times the token has been transferred"},"getVaultAddress(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getVaultAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"see {IHookCoveredCall-getVaultAddress}."},"initialize(address,address,address,address)":{inputs:[{internalType:"address",name:"protocol",type:"address"},{internalType:"address",name:"nftContract",type:"address"},{internalType:"address",name:"hookVaultFactory",type:"address"},{internalType:"address",name:"preApprovedMarketplace",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",details:"Because the deployed contract is proxied, arguments unique to each deployment must be passed in an individual initializer. This function is like a constructor.",params:{hookVaultFactory:"the address of the ERC-721 vault registry",nftContract:"the address for the ERC-721 contract that can serve as underlying instruments",preApprovedMarketplace:"the address of the contract which will automatically approved to transfer option ERC721s owned by any account when they're minted",protocol:"the address of the Hook protocol (which contains configurations)"},notice:"Initializes the specific instance of the instrument contract."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC721-isApprovedForAll}. this extension ensures that any operator contract located at {_approvedMarketpace} is considered approved internally in the ERC721 contract"},"mintWithEntitledVault(address,uint32,uint128,uint32)":{inputs:[{internalType:"address",name:"vaultAddress",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint128",name:"strikePrice",type:"uint128"},{internalType:"uint32",name:"expirationTime",type:"uint32"}],name:"mintWithEntitledVault",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"See {IHookCoveredCall-mintWithEntitledVault}."},"mintWithErc721(address,uint256,uint128,uint32)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint128",name:"strikePrice",type:"uint128"},{internalType:"uint32",name:"expirationTime",type:"uint32"}],name:"mintWithErc721",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"See {IHookCoveredCall-mintWithErc721}."},"mintWithVault(address,uint32,uint128,uint32,(uint8,uint8,bytes32,bytes32))":{inputs:[{internalType:"address",name:"vaultAddress",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint128",name:"strikePrice",type:"uint128"},{internalType:"uint32",name:"expirationTime",type:"uint32"},{components:[{internalType:"enum Signatures.SignatureType",name:"signatureType",type:"uint8"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],internalType:"struct Signatures.Signature",name:"signature",type:"tuple"}],name:"mintWithVault",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"See {IHookCoveredCall-mintWithVault}."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-name}."},"optionClaims(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"optionClaims",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"optionParams(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"optionParams",outputs:[{internalType:"address",name:"writer",type:"address"},{internalType:"uint32",name:"expiration",type:"uint32"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"vaultAddress",type:"address"},{internalType:"uint128",name:"strike",type:"uint128"},{internalType:"uint128",name:"bid",type:"uint128"},{internalType:"address",name:"highBidder",type:"address"},{internalType:"bool",name:"settled",type:"bool"}],stateMutability:"view",type:"function"},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-ownerOf}."},"reclaimAsset(uint256,bool)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"},{internalType:"bool",name:"returnNft",type:"bool"}],name:"reclaimAsset",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookCoveredCall-reclaimAsset}."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-setApprovalForAll}."},"setBidIncrement(uint256)":{inputs:[{internalType:"uint256",name:"newBidIncrement",type:"uint256"}],name:"setBidIncrement",outputs:[],stateMutability:"nonpayable",type:"function",details:"set the minimum overage, in bips, for a new bid compared to the current bid.",params:{newBidIncrement:"the minimum bid increment in basis points (1/100th of 1%)"}},"setMarketPaused(bool)":{inputs:[{internalType:"bool",name:"paused",type:"bool"}],name:"setMarketPaused",outputs:[],stateMutability:"nonpayable",type:"function",details:"sets a paused / unpaused state for the market corresponding to this contract",params:{paused:"should the market be set to paused or unpaused"}},"setMinOptionDuration(uint256)":{inputs:[{internalType:"uint256",name:"newMinDuration",type:"uint256"}],name:"setMinOptionDuration",outputs:[],stateMutability:"nonpayable",type:"function",details:"configures the minimum duration for a newly minted option. Options must be at least this far away in the future.",params:{newMinDuration:"is the minimum option duration in seconds"}},"setSettlementAuctionStartOffset(uint256)":{inputs:[{internalType:"uint256",name:"newSettlementStartOffset",type:"uint256"}],name:"setSettlementAuctionStartOffset",outputs:[],stateMutability:"nonpayable",type:"function",details:"set the settlement auction start offset. Settlement auctions begin at this time prior to expiration.",params:{newSettlementStartOffset:"in seconds (i.e. block.timestamp increments)"}},"settleOption(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"settleOption",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookCoveredCall-settleOption}."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-symbol}."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721-tokenURI}."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-transferFrom}."}}},"src/HookERC721MultiVaultImplV1.sol:HookERC721MultiVaultImplV1":{source:"src/HookERC721MultiVaultImplV1.sol",name:"HookERC721MultiVaultImplV1",title:"HookMultiVault-implementation of a Vault for multiple assets within a NFT collection, with entitlements.",author:"Jake Nyquist - j@hook.xyz",details:"This contract implements ERC721Receiver This contract views the tokenId for the asset on the ERC721 contract as the corresponding assetId for that asset when deposited into the vault",notice:'HookVault holds a multiple NFT asset in escrow on behalf of multiple beneficial owners. Other contracts are able to register "entitlements" for a fixed period of time on the asset, which give them the ability to change the vault\'s owner.',constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficialOwner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint32",name:"assetId",type:"uint32"}],name:"Approval",type:"event",notice:"Emitted when `beneficialOwner` enables `approved` to manage the `assetId` asset."},"AssetFlashLoaned(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"address",name:"flashLoanImpl",type:"address"}],name:"AssetFlashLoaned",type:"event",notice:"emitted after an asset is flash loaned by its beneficial owner."},"AssetReceived(address,address,address,uint32)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"address",name:"contractAddress",type:"address"},{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"}],name:"AssetReceived",type:"event",notice:"emitted when an asset is added into the vault"},"AssetWithdrawn(uint32,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"AssetWithdrawn",type:"event",notice:"emitted when an asset is withdrawn from the vault"},"BeneficialOwnerSet(uint32,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"},{indexed:!1,internalType:"address",name:"setBy",type:"address"}],name:"BeneficialOwnerSet",type:"event",notice:"emitted when the beneficial owner of an asset changes"},"EntitlementCleared(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"assetId",type:"uint256"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"EntitlementCleared",type:"event",notice:"emitted when an entitlement is cleared from an asset"},"EntitlementImposed(uint32,address,uint32,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"entitledAccount",type:"address"},{indexed:!1,internalType:"uint32",name:"expiry",type:"uint32"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"EntitlementImposed",type:"event",notice:"emitted when an entitlement is placed on an asset"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event"}},methods:{"EIP712_DOMAIN_SEPARATOR()":{inputs:[],name:"EIP712_DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"approveOperator(address,uint32)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"}],name:"approveOperator",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookVault-approveOperator}."},"assetAddress(uint32)":{inputs:[{internalType:"uint32",name:"",type:"uint32"}],name:"assetAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"assetTokenId(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"assetTokenId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the underlying token ID for a given asset. In this case the tokenId == the assetId"},"clearEntitlement(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"clearEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-clearEntitlement}.This can only be called if an entitlement currently exists, otherwise it would be a no-op"},"clearEntitlementAndDistribute(uint32,address)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"receiver",type:"address"}],name:"clearEntitlementAndDistribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-clearEntitlementAndDistribute}.The entitlement must be exist, and must be called by the {operator}. The operator can specify a intended receiver, which should match the beneficialOwner. The function will throw if the receiver and owner do not match.",params:{assetId:"the id of the specific vaulted asset",receiver:"the intended receiver of the asset"}},"entitlementExpiration(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"entitlementExpiration",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",details:"See {IHookVault-entitlementExpiration}."},"flashLoan(uint32,address,bytes)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"receiverAddress",type:"address"},{internalType:"bytes",name:"params",type:"bytes"}],name:"flashLoan",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-flashLoan}."},"getApprovedOperator(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getApprovedOperator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IHookVault-getApprovedOperator}."},"getBeneficialOwner(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getBeneficialOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IHookERC721Vault-getBeneficialOwner}."},"getCurrentEntitlementOperator(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getCurrentEntitlementOperator",outputs:[{internalType:"bool",name:"",type:"bool"},{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetId:"the id of the underlying asset"},notice:"looks up the current operator of an entitlement on an asset"},"getHoldsAsset(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getHoldsAsset",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IHookERC721Vault-getHoldsAsset}."},"grantEntitlement((address,address,address,uint32,uint32))":{inputs:[{components:[{internalType:"address",name:"beneficialOwner",type:"address"},{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"vaultAddress",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint32",name:"expiry",type:"uint32"}],internalType:"struct Entitlements.Entitlement",name:"entitlement",type:"tuple"}],name:"grantEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-grantEntitlement}.The entitlement must be sent by the current beneficial owner"},"hasActiveEntitlement(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"hasActiveEntitlement",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"imposeEntitlement(address,uint32,uint32,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint32",name:"expiry",type:"uint32"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"imposeEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-imposeEntitlement}.The entitlement must be signed by the current beneficial owner of the contract. Anyone can submit the entitlement"},"initialize(address,address)":{inputs:[{internalType:"address",name:"nftContract",type:"address"},{internalType:"address",name:"hookAddress",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"-constructor"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`."},"setBeneficialOwner(uint32,address)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"newBeneficialOwner",type:"address"}],name:"setBeneficialOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-setBeneficialOwner}. setBeneficialOwner can only be called by the entitlementContract if there is an activeEntitlement."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"validateEntitlementSignature(address,uint32,uint32,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint32",name:"expiry",type:"uint32"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"validateEntitlementSignature",outputs:[],stateMutability:"view",type:"function",details:"Validates that a specific signature is actually the entitlement EIP-712 signed by the beneficial owner specified in the entitlement."},"withdrawalAsset(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"withdrawalAsset",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-withdrawalAsset}.withdrawals can only be performed to the beneficial owner if there are no entitlements"}}},"src/HookERC721VaultFactory.sol:HookERC721VaultFactory":{source:"src/HookERC721VaultFactory.sol",name:"HookERC721VaultFactory",title:"Hook Vault Factory",author:"Jake Nyquist-j@hook.xyz",details:"See {IHookERC721VaultFactory}.The factory itself is non-upgradeable; however, each vault is upgradeable (i.e. all vaults) created by this factory can be upgraded at one time via the beacon pattern.",constructor:{inputs:[{internalType:"address",name:"hookProtocolAddress",type:"address"},{internalType:"address",name:"beaconAddress",type:"address"},{internalType:"address",name:"multiBeaconAddress",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"ERC721MultiVaultCreated(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"nftAddress",type:"address"},{indexed:!1,internalType:"address",name:"vaultAddress",type:"address"}],name:"ERC721MultiVaultCreated",type:"event",notice:"emitted when a new MultiVault is deployed by the protocol"},"ERC721VaultCreated(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"nftAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"address",name:"vaultAddress",type:"address"}],name:"ERC721VaultCreated",type:"event"}},methods:{"ALLOWLISTER_ROLE()":{inputs:[],name:"ALLOWLISTER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the allowlister is able to enable and disable projects to mint instruments"},"CALL_UPGRADER()":{inputs:[],name:"CALL_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the call upgrader role is able to upgrade the implementation of the covered call options"},"COLLECTION_CONF()":{inputs:[],name:"COLLECTION_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the collection configuration role allows the actor to make changes the collection configs on the protocol contract"},"MARKET_CONF()":{inputs:[],name:"MARKET_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the market configuration role allows the actor to make changes to how the market operates"},"PAUSER_ROLE()":{inputs:[],name:"PAUSER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the pauser is able to start and pause various components of the protocol"},"VAULT_UPGRADER()":{inputs:[],name:"VAULT_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the vault upgrader role is able to upgrade the implementation for all vaults"},"findOrCreateVault(address,uint256)":{inputs:[{internalType:"address",name:"nftAddress",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"findOrCreateVault",outputs:[{internalType:"contract IHookERC721Vault",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",notice:"See {IHookERC721VaultFactory-findOrCreateVault}."},"getMultiVault(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"getMultiVault",outputs:[{internalType:"contract IHookERC721Vault",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Registry of all of the active multi-vaults within the protocol"},"getVault(address,uint256)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"}],name:"getVault",outputs:[{internalType:"contract IHookERC721Vault",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"Registry of all of the active vaults within the protocol, allowing users to find vaults by project address and tokenId;"},"makeMultiVault(address)":{inputs:[{internalType:"address",name:"nftAddress",type:"address"}],name:"makeMultiVault",outputs:[{internalType:"contract IHookERC721Vault",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",notice:"See {IHookERC721VaultFactory-makeMultiVault}."},"makeSoloVault(address,uint256)":{inputs:[{internalType:"address",name:"nftAddress",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"makeSoloVault",outputs:[{internalType:"contract IHookERC721Vault",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",notice:"See {IHookERC721VaultFactory-makeSoloVault}."}}},"src/HookERC721VaultImplV1.sol:HookERC721VaultImplV1":{source:"src/HookERC721VaultImplV1.sol",name:"HookERC721VaultImplV1",title:"HookVault-implementation of a Vault for a single NFT asset, with entitlements.",author:"Jake Nyquist - j@hook.xyz",details:"This contract implements ERC721Receiver and extends the MultiVault, simply treating the stored asset as assetId 0 in all cases. SEND TRANSACTION -     (1) owners are able to forward transactions to this vault to other wallets     (2) calls to the ERC-721 address are blocked to prevent approvals from being set on the         NFT while in escrow, which could allow for theft     (3) At the end of each transaction, the ownerOf the vaulted token must still be the vault",notice:'HookVault holds a single NFT asset in escrow on behalf of a user. Other contracts are able to register "entitlements" for a fixed period of time on the asset, which give them the ability to change the vault\'s owner.',constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficialOwner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint32",name:"assetId",type:"uint32"}],name:"Approval",type:"event",notice:"Emitted when `beneficialOwner` enables `approved` to manage the `assetId` asset."},"AssetFlashLoaned(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"address",name:"flashLoanImpl",type:"address"}],name:"AssetFlashLoaned",type:"event",notice:"emitted after an asset is flash loaned by its beneficial owner."},"AssetReceived(address,address,address,uint32)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"address",name:"contractAddress",type:"address"},{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"}],name:"AssetReceived",type:"event",notice:"emitted when an asset is added into the vault"},"AssetWithdrawn(uint32,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"AssetWithdrawn",type:"event",notice:"emitted when an asset is withdrawn from the vault"},"BeneficialOwnerSet(uint32,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"},{indexed:!1,internalType:"address",name:"setBy",type:"address"}],name:"BeneficialOwnerSet",type:"event",notice:"emitted when the beneficial owner of an asset changes"},"EntitlementCleared(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"assetId",type:"uint256"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"EntitlementCleared",type:"event",notice:"emitted when an entitlement is cleared from an asset"},"EntitlementImposed(uint32,address,uint32,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"entitledAccount",type:"address"},{indexed:!1,internalType:"uint32",name:"expiry",type:"uint32"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"EntitlementImposed",type:"event",notice:"emitted when an entitlement is placed on an asset"},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event"}},methods:{"EIP712_DOMAIN_SEPARATOR()":{inputs:[],name:"EIP712_DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"approveOperator(address,uint32)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"}],name:"approveOperator",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookVault-approveOperator}."},"assetAddress(uint32)":{inputs:[{internalType:"uint32",name:"",type:"uint32"}],name:"assetAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"assetTokenId(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"assetTokenId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"returns the underlying token ID for a given asset. In this case the tokenId == the assetId"},"clearEntitlement(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"clearEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-clearEntitlement}.This can only be called if an entitlement currently exists, otherwise it would be a no-op"},"clearEntitlementAndDistribute(uint32,address)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"receiver",type:"address"}],name:"clearEntitlementAndDistribute",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-clearEntitlementAndDistribute}.The entitlement must be exist, and must be called by the {operator}. The operator can specify a intended receiver, which should match the beneficialOwner. The function will throw if the receiver and owner do not match.",params:{assetId:"the id of the specific vaulted asset",receiver:"the intended receiver of the asset"}},"entitlementExpiration(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"entitlementExpiration",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",details:"See {IHookVault-entitlementExpiration}."},"execTransaction(address,bytes)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"execTransaction",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"payable",type:"function",details:"See {IHookERC721Vault-execTransaction}.Allows a beneficial owner to send an arbitrary call from this wallet as long as the underlying NFT is still owned by us after the transaction. The ether value sent is forwarded. Return value is suppressed. Because this contract holds only a single asset owned by a single address, it supports calling exec transaction from this address because such calls are unlikely to impact other owner's assets."},"flashLoan(uint32,address,bytes)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"receiverAddress",type:"address"},{internalType:"bytes",name:"params",type:"bytes"}],name:"flashLoan",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-flashLoan}."},"getApprovedOperator(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getApprovedOperator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IHookVault-getApprovedOperator}."},"getBeneficialOwner(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getBeneficialOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IHookERC721Vault-getBeneficialOwner}."},"getCurrentEntitlementOperator(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getCurrentEntitlementOperator",outputs:[{internalType:"bool",name:"",type:"bool"},{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetId:"the id of the underlying asset"},notice:"looks up the current operator of an entitlement on an asset"},"getHoldsAsset(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getHoldsAsset",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IHookERC721Vault-getHoldsAsset}."},"grantEntitlement((address,address,address,uint32,uint32))":{inputs:[{components:[{internalType:"address",name:"beneficialOwner",type:"address"},{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"vaultAddress",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint32",name:"expiry",type:"uint32"}],internalType:"struct Entitlements.Entitlement",name:"entitlement",type:"tuple"}],name:"grantEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-grantEntitlement}.The entitlement must be sent by the current beneficial owner"},"hasActiveEntitlement(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"hasActiveEntitlement",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"imposeEntitlement(address,uint32,uint32,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint32",name:"expiry",type:"uint32"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"imposeEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-imposeEntitlement}.The entitlement must be signed by the current beneficial owner of the contract. Anyone may call this function and successfully impose the entitlement as long as the signature is valid."},"initialize(address,address)":{inputs:[{internalType:"address",name:"nftContract",type:"address"},{internalType:"address",name:"hookAddress",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"-constructor"},"initialize(address,uint256,address)":{inputs:[{internalType:"address",name:"nftContract",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"address",name:"hookAddress",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",notice:"-constructor"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}. Always returns `IERC721Receiver.onERC721Received.selector`. This method requires an override implementation because the the arguments must be embedded in the body of the function"},"setBeneficialOwner(uint32,address)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"newBeneficialOwner",type:"address"}],name:"setBeneficialOwner",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-setBeneficialOwner}."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"validateEntitlementSignature(address,uint32,uint32,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint32",name:"expiry",type:"uint32"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"validateEntitlementSignature",outputs:[],stateMutability:"view",type:"function",details:"Validates that a specific signature is actually the entitlement EIP-712 signed by the beneficial owner specified in the entitlement."},"withdrawalAsset(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"withdrawalAsset",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IHookERC721Vault-withdrawalAsset}.withdrawals can only be performed by the beneficial owner if there are no entitlements"}}},"src/HookProtocol.sol:HookProtocol":{source:"src/HookProtocol.sol",name:"HookProtocol",details:"Other contracts in the protocol refer to this one to get configuration and pausing issues. to reduce attack surface area, this contract cannot be upgraded; however, additional roles can be added. This contract does not implement any specific timelocks or other safety measures. The roles are granted with the principal of least privilege. As the protocol matures, these additional measures can be layered by granting these roles to other contracts. In the extreme, the upgrade and other roles can be burned, which would effectively make the protocol static and non-upgradeable.",constructor:{inputs:[{internalType:"address",name:"allowlister",type:"address"},{internalType:"address",name:"pauser",type:"address"},{internalType:"address",name:"vaultUpgrader",type:"address"},{internalType:"address",name:"callUpgrader",type:"address"},{internalType:"address",name:"marketConf",type:"address"},{internalType:"address",name:"collectionConf",type:"address"},{internalType:"address",name:"weth",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"Paused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Paused",type:"event"},"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"},"Unpaused(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"account",type:"address"}],name:"Unpaused",type:"event"}},stateVariables:{"getWETHAddress()":{inputs:[],name:"getWETHAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",details:"these are values for popular chains: mainnet: 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 kovan: 0xd0a1e359811322d97991e03f863a0c30c2cf029c ropsten: 0xc778417e063141139fce010982780140aa0cd5ab rinkeby: 0xc778417e063141139fce010982780140aa0cd5ab",return:"the weth address",returns:{_0:"the weth address"},notice:"the standard weth address on this chain"}},methods:{"ALLOWLISTER_ROLE()":{inputs:[],name:"ALLOWLISTER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the allowlister is able to enable and disable projects to mint instruments"},"CALL_UPGRADER()":{inputs:[],name:"CALL_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the call upgrader role is able to upgrade the implementation of the covered call options"},"COLLECTION_CONF()":{inputs:[],name:"COLLECTION_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the collection configuration role allows the actor to make changes the collection configs on the protocol contract"},"DEFAULT_ADMIN_ROLE()":{inputs:[],name:"DEFAULT_ADMIN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MARKET_CONF()":{inputs:[],name:"MARKET_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the market configuration role allows the actor to make changes to how the market operates"},"PAUSER_ROLE()":{inputs:[],name:"PAUSER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the pauser is able to start and pause various components of the protocol"},"VAULT_UPGRADER()":{inputs:[],name:"VAULT_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the vault upgrader role is able to upgrade the implementation for all vaults"},"coveredCallContract()":{inputs:[],name:"coveredCallContract",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"the address of the deployed CoveredCallFactory used by the protocol"},"getCollectionConfig(address,bytes32)":{inputs:[{internalType:"address",name:"collectionAddress",type:"address"},{internalType:"bytes32",name:"conf",type:"bytes32"}],name:"getCollectionConfig",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IHookProtocol-getCollectionConfig}."},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"pauses the protocol if the protocol is currently unpaused"},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if the contract is paused, and false otherwise."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"setCollectionConfig(address,bytes32,bool)":{inputs:[{internalType:"address",name:"collectionAddress",type:"address"},{internalType:"bytes32",name:"config",type:"bytes32"},{internalType:"bool",name:"value",type:"bool"}],name:"setCollectionConfig",outputs:[],stateMutability:"nonpayable",type:"function",details:"the conf value can be read with getCollectionConfig",params:{collectionAddress:"the address for the collection",config:"the configuration field to set",value:"the value to set for the configuration"},notice:"allows an account with the COLLECTION_CONF role to set a boolean config value for a collection"},"setCoveredCallFactory(address)":{inputs:[{internalType:"address",name:"coveredCallFactoryContract",type:"address"}],name:"setCoveredCallFactory",outputs:[],stateMutability:"nonpayable",type:"function",details:"This address is used by other protocols searching for the registry of protocols.",params:{coveredCallFactoryContract:"the address of the deployed covered call contract"},notice:"Allows an admin to set the address of the deployed covered call factory"},"setVaultFactory(address)":{inputs:[{internalType:"address",name:"vaultFactoryContract",type:"address"}],name:"setVaultFactory",outputs:[],stateMutability:"nonpayable",type:"function",details:"allows all protocol components, including the call factory, to look up the vault factory.",params:{vaultFactoryContract:"the deployed vault factory"},notice:"Allows an admin to set the address of the deployed vault factory"},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"throwWhenPaused()":{inputs:[],name:"throwWhenPaused",outputs:[],stateMutability:"view",type:"function",notice:"throws an exception when the protocol is paused"},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"unpauses the protocol if the protocol is already paused"},"vaultContract()":{inputs:[],name:"vaultContract",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"the address of the deployed VaultFactory used by the protocol"}}},"src/HookUpgradeableBeacon.sol:HookUpgradeableBeacon":{source:"src/HookUpgradeableBeacon.sol",name:"HookUpgradeableBeacon",details:"This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their implementation contract, which is where they will delegate all function calls. An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon. Ownership is managed centrally on the Hook protocol level, where the owner is the holder of a specific permission. This permission should be used only for the purpose of upgrading the particular contract (i.e., the permissions should not be reused). This contract is deliberately simple and only has one non-view method - `upgrade`. Timelocks or other upgrade conditions will be managed by the owner of this contract. This contract is based on the UpgradeableBeaconContract from OZ and DharmaUpgradeBeaconController from Dharma",constructor:{inputs:[{internalType:"address",name:"implementation_",type:"address"},{internalType:"address",name:"hookProtocol",type:"address"},{internalType:"bytes32",name:"upgraderRole",type:"bytes32"}],stateMutability:"nonpayable",type:"constructor"},events:{"Upgraded(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"implementation",type:"address"}],name:"Upgraded",type:"event",details:"Emitted when the implementation returned by the beacon is changed."}},methods:{"ALLOWLISTER_ROLE()":{inputs:[],name:"ALLOWLISTER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the allowlister is able to enable and disable projects to mint instruments"},"CALL_UPGRADER()":{inputs:[],name:"CALL_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the call upgrader role is able to upgrade the implementation of the covered call options"},"COLLECTION_CONF()":{inputs:[],name:"COLLECTION_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the collection configuration role allows the actor to make changes the collection configs on the protocol contract"},"MARKET_CONF()":{inputs:[],name:"MARKET_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the market configuration role allows the actor to make changes to how the market operates"},"PAUSER_ROLE()":{inputs:[],name:"PAUSER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the pauser is able to start and pause various components of the protocol"},"VAULT_UPGRADER()":{inputs:[],name:"VAULT_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the vault upgrader role is able to upgrade the implementation for all vaults"},"implementation()":{inputs:[],name:"implementation",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the current implementation address."},"upgradeTo(address)":{inputs:[{internalType:"address",name:"newImplementation",type:"address"}],name:"upgradeTo",outputs:[],stateMutability:"nonpayable",type:"function",details:"Upgrades the beacon to a new implementation. Emits an {Upgraded} event. Requirements: - msg.sender must be the owner of the contract. - `newImplementation` must be a contract."}}},"src/interfaces/IERC721FlashLoanReceiver.sol:IERC721FlashLoanReceiver":{source:"src/interfaces/IERC721FlashLoanReceiver.sol",name:"IERC721FlashLoanReceiver",title:"Flash Loan Operator Interface (ERC-721)",author:"Jake Nyquist-j@hook.xyz",details:"contracts that will utilize vaulted assets in flash loans should implement this interface in order to receive the asset. Users may want to receive the asset within a single block to claim airdrops, participate in governance, and other things with their assets. The implementer may do whatever they like with the vaulted NFT within the executeOperation method, so long as they approve the vault (passed as a param) to operate the underlying NFT. The Vault will move the asset back into the vault after executionOperation returns, and also validate that it is the owner of the asset. The flashloan receiver is able to abort a flashloan by returning false from the executeOperation method.",methods:{"executeOperation(address,uint256,address,address,bytes)":{inputs:[{internalType:"address",name:"nftContract",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"address",name:"beneficialOwner",type:"address"},{internalType:"address",name:"vault",type:"address"},{internalType:"bytes",name:"params",type:"bytes"}],name:"executeOperation",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"executeOperation is called immediately after the asset is transferred to this contract. After return, the asset is returned to the vault by the vault contract. The executeOperation implementation MUST approve the {vault} to operate the transferred NFT i.e. `IERC721(nftContract).setApprovalForAll(vault, true);`",params:{beneficialOwner:"the current beneficialOwner of the vault, who initialized the flashLoan",nftContract:"the address of the underlying erc-721 asset",params:"additional params passed by the caller into the flashloan",tokenId:"the address of the received erc-721 asset",vault:"the address of the vault performing the flashloan (in most cases, equal to msg.sender)"},notice:"the method that contains the operations to be performed with the loaned asset"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom} by `operator` from `from`, this function is called. It must return its Solidity selector to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted. The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`."}}},"src/interfaces/IHookCoveredCall.sol:IHookCoveredCall":{source:"src/interfaces/IHookCoveredCall.sol",name:"IHookCoveredCall",title:"A covered call instrument",author:"Jake Nyquist-j@hook.xyz",notice:'This contract implements a "Covered Call Option". A call option gives the holder the right, but not the obligation to purchase an asset at a fixed time in the future (the expiry) for a fixed price (the strike). This call option implementation here is similar to a "european" call option because the asset can only be purchased at the expiration. The call option is "covered"  because the underlying asset, must be held in escrow within a IHookVault for the entire duration of the option. There are three phases to the call option: (1) WRITING: The owner of the NFT can mint an option by calling the "mint" function using the parameters of the subject ERC-721; specifying additionally their preferred strike price and expiration. An "instrument nft" is minted to the writer\'s address, where the holder of this ERC-721 will receive the economic benefit of holding the option. (2) SALE: The sale occurs outside of the context of this contract; however, the ZeroEx market contracts are pre-approved to transfer the tokens. By Selling the instrument NFT, the writer earns a "premium" for selling their option. The option may be sold and re-sold multiple times. (3) SETTLEMENT: One day prior to the expiration, and auction begins. People are able to call bid() for more than the strike price to place a bid. If, at settlement, the high bid is greater than the strike, (b-strike) is transferred to the holder of the instrument NFT, the strike price is transferred to the writer. The high bid is transferred to the holder of the option.',events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Bid(uint256,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"bidAmount",type:"uint256"},{indexed:!1,internalType:"address",name:"bidder",type:"address"}],name:"Bid",type:"event",params:{bidAmount:"the amount of wei bid",bidder:"the account placing the bid that is now the high bidder",optionId:"the option for the underlying that was bid on"},notice:"emitted when a call option settlement auction gets and accepts a new bid"},"CallCreated(address,address,uint256,uint256,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"writer",type:"address"},{indexed:!1,internalType:"address",name:"vaultAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"assetId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"},{indexed:!1,internalType:"uint256",name:"strikePrice",type:"uint256"},{indexed:!1,internalType:"uint256",name:"expiration",type:"uint256"}],name:"CallCreated",type:"event",notice:"emitted when a new call option is successfully minted with a specific underlying vault"},"CallProceedsDistributed(uint256,address,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"},{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"amount",type:"uint256"}],name:"CallProceedsDistributed",type:"event",params:{amount:"the amount of the claim distributed",optionId:"the option the claim is on",to:"the option owner making the claim"},notice:"emitted when an option owner claims their proceeds"},"CallReclaimed(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"}],name:"CallReclaimed",type:"event",notice:"emitted when a call option is reclaimed"},"CallSettled(uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"},{indexed:!1,internalType:"bool",name:"claimable",type:"bool"}],name:"CallSettled",type:"event",notice:"emitted when a call option is settled"},"ExpiredCallBurned(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"optionId",type:"uint256"}],name:"ExpiredCallBurned",type:"event",notice:"emitted when a expired call option is burned"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"Gives permission to `to` to transfer `tokenId` token to another account. The approval is cleared when the token is transferred. Only a single account can be approved at a time, so approving the zero address clears previous approvals. Requirements: - The caller must own the token or be an approved operator. - `tokenId` must exist. Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"balance",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of tokens in ``owner``'s account."},"bid(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"bid",outputs:[],stateMutability:"payable",type:"function",params:{optionId:"the optionId corresponding to the settlement to bid on."},notice:"Bid in the settlement auction for an option. The paid amount is the bid, and the bidder is required to escrow this amount until either the auction ends or another bidder bids higher The bid must be greater than the strike price"},"burnExpiredOption(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"burnExpiredOption",outputs:[],stateMutability:"nonpayable",type:"function",params:{optionId:"of the option to burn."},notice:"Allows anyone to burn the instrument NFT for an expired option."},"claimOptionProceeds(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"claimOptionProceeds",outputs:[],stateMutability:"nonpayable",type:"function",details:"this mechanism prevents the proceeds from being sent to an account temporarily custodying the option asset.",params:{optionId:"the option to claim and burn."},notice:"allows the option owner to claim proceeds if the option was settled by another account. The option NFT is burned after settlement."},"currentBid(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"currentBid",outputs:[{internalType:"uint128",name:"",type:"uint128"}],stateMutability:"view",type:"function",params:{optionId:"of the option to check"},notice:"view function to get the current high settlement bid of an option, or 0 if there is no high bid"},"currentBidder(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"currentBidder",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{optionId:"of the option to check"},returns:{_0:"address of the account for the current high bidder, or the null address if there is none"},notice:"view function to get the current high bidder for an option settlement auction, or the null address if no high bidder exists"},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"operator",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `tokenId` must exist."},"getOptionIdForAsset(address,uint32)":{inputs:[{internalType:"address",name:"vault",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getOptionIdForAsset",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"getOptionIdForAsset",params:{assetId:"the id of the asset to check",vault:"the address of the hook vault that holds the covered asset"},returns:{_0:"the optionId, if one exists or 0 otherwise"},notice:"Looks up the latest optionId that covers a particular asset, if one exists. This option may be already settled."},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns if the `operator` is allowed to manage all of the assets of `owner`. See {setApprovalForAll}"},"mintWithEntitledVault(address,uint32,uint128,uint32)":{inputs:[{internalType:"address",name:"vaultAddress",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint128",name:"strikePrice",type:"uint128"},{internalType:"uint32",name:"expirationTime",type:"uint32"}],name:"mintWithEntitledVault",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{assetId:"the id of the asset within the vault",expirationTime:"time the timestamp after which the option will be expired",strikePrice:"the strike price for the call option being written",vaultAddress:"the contract address of the vault currently holding the call option"},notice:"Mints a new call option for the assets deposited in a particular vault given strike price and expiration. That vault must already have a registered entitlement for this contract with the an expiration equal to {expirationTime}"},"mintWithErc721(address,uint256,uint128,uint32)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"uint128",name:"strikePrice",type:"uint128"},{internalType:"uint32",name:"expirationTime",type:"uint32"}],name:"mintWithErc721",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{expirationTime:"time the timestamp after which the option will be expired",strikePrice:"the strike price for the call option being written",tokenAddress:"the contract address of the ERC-721 token that serves as the underlying asset for the call option",tokenId:"the tokenId of the underlying ERC-721 token"},notice:'Mints a new call option for a particular "underlying" ERC-721 NFT with a given strike price and expiration'},"mintWithVault(address,uint32,uint128,uint32,(uint8,uint8,bytes32,bytes32))":{inputs:[{internalType:"address",name:"vaultAddress",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint128",name:"strikePrice",type:"uint128"},{internalType:"uint32",name:"expirationTime",type:"uint32"},{components:[{internalType:"enum Signatures.SignatureType",name:"signatureType",type:"uint8"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],internalType:"struct Signatures.Signature",name:"signature",type:"tuple"}],name:"mintWithVault",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",params:{assetId:"the id of the asset within the vault",expirationTime:"time the timestamp after which the option will be expired",signature:"the signature used to place the entitlement onto the vault",strikePrice:"the strike price for the call option being written",vaultAddress:"the contract address of the vault currently holding the call option"},notice:"Mints a new call option for the assets deposited in a particular vault given strike price and expiration."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection name."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"owner",type:"address"}],stateMutability:"view",type:"function",details:"Returns the owner of the `tokenId` token. Requirements: - `tokenId` must exist."},"reclaimAsset(uint256,bool)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"},{internalType:"bool",name:"returnNft",type:"bool"}],name:"reclaimAsset",outputs:[],stateMutability:"nonpayable",type:"function",details:"Allows the writer to reclaim a NFT if they also hold the option NFT.",params:{optionId:"the option being reclaimed.",returnNft:"true if token should be withdrawn from vault, false to leave token in the vault."},notice:"Allows the writer to reclaim an entitled asset. This is only possible when the writer holds the option nft and calls this function."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients are aware of the ERC721 protocol to prevent tokens from being forever locked. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Safely transfers `tokenId` token from `from` to `to`. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must exist and be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer. Emits a {Transfer} event."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"_approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"Approve or remove `operator` as an operator for the caller. Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller. Requirements: - The `operator` cannot be the caller. Emits an {ApprovalForAll} event."},"settleOption(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"settleOption",outputs:[],stateMutability:"nonpayable",type:"function",details:"the return nft param allows the underlying asset to remain in its vault. This saves gas compared to first distributing it and then re-depositing it. No royalties or other payments are subtracted from the distribution amounts.",params:{optionId:"of the option to settle."},notice:"Permissionlessly settle an expired option when the option expires in the money, distributing the proceeds to the Writer, Holder, and Bidder as follows: WRITER (who originally called mint() and owned underlying asset) - receives the `strike` HOLDER (ownerOf(optionId)) - receives `b-strike` HIGH BIDDER (call.highBidder) - becomes ownerOf NFT, pays `bid`."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the token collection symbol."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the Uniform Resource Identifier (URI) for `tokenId` token."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers `tokenId` token from `from` to `to`. WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible. Requirements: - `from` cannot be the zero address. - `to` cannot be the zero address. - `tokenId` token must be owned by `from`. - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}. Emits a {Transfer} event."}}},"src/interfaces/IHookCoveredCallFactory.sol:IHookCoveredCallFactory":{source:"src/interfaces/IHookCoveredCallFactory.sol",name:"IHookCoveredCallFactory",title:"HookCoveredCallFactory-factory for instances of the Covered Call contract",author:"Jake Nyquist-j@hook.xyz",notice:"The Factory creates covered call instruments that support specific ERC-721 contracts, and also tracks all of the existing active markets.",events:{"CoveredCallInstrumentCreated(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"assetAddress",type:"address"},{indexed:!1,internalType:"address",name:"instrumentAddress",type:"address"}],name:"CoveredCallInstrumentCreated",type:"event",details:"emitted whenever a new call instrument instance is created",params:{assetAddress:"the address of the asset underlying the covered call",instrumentAddress:"the address of the covered call instrument"}}},methods:{"getCallInstrument(address)":{inputs:[{internalType:"address",name:"assetAddress",type:"address"}],name:"getCallInstrument",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetAddress:"the contract address for the underlying asset"},returns:{_0:"the address of the instrument contract or the null address if one does not exist"},notice:"Lookup the call instrument contract based on the asset address"},"makeCallInstrument(address)":{inputs:[{internalType:"address",name:"assetAddress",type:"address"}],name:"makeCallInstrument",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",params:{assetAddress:"the address for the underling asset"},returns:{_0:"the address of the call option instrument contract (upgradeable)"},notice:"Create a call option instrument for a specific underlying asset address"}}},"src/interfaces/IHookERC20Vault.sol:IHookERC20Vault":{source:"src/interfaces/IHookERC20Vault.sol",name:"IHookERC20Vault",title:"Hook ERC-20 Vault interface",author:"Jake Nyquist-j@hook.xyz",details:"the IHookERC20 vault is an extension of the standard IHookVault specifically designed to hold and receive ERC20 Tokens.",events:{"Approval(address,address,uint32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficialOwner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint32",name:"assetId",type:"uint32"}],name:"Approval",type:"event",notice:"Emitted when `beneficialOwner` enables `approved` to manage the `assetId` asset."},"AssetReceived(address,address,address,uint32)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"address",name:"contractAddress",type:"address"},{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"}],name:"AssetReceived",type:"event",notice:"emitted when an asset is added into the vault"},"AssetWithdrawn(uint32,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"AssetWithdrawn",type:"event",notice:"emitted when an asset is withdrawn from the vault"},"BeneficialOwnerSet(uint32,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"},{indexed:!1,internalType:"address",name:"setBy",type:"address"}],name:"BeneficialOwnerSet",type:"event",notice:"emitted when the beneficial owner of an asset changes"},"EntitlementCleared(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"assetId",type:"uint256"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"EntitlementCleared",type:"event",notice:"emitted when an entitlement is cleared from an asset"},"EntitlementImposed(uint32,address,uint32,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"entitledAccount",type:"address"},{indexed:!1,internalType:"uint32",name:"expiry",type:"uint32"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"EntitlementImposed",type:"event",notice:"emitted when an entitlement is placed on an asset"}},methods:{"approveOperator(address,uint32)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"}],name:"approveOperator",outputs:[],stateMutability:"nonpayable",type:"function",details:"Only a single account can be approved at a time, so approving the zero address clears previous approvals.   * Requirements: -  The caller must be the beneficial owner - `tokenId` must exist. Emits an {Approval} event.",notice:"Gives permission to `to` to impose an entitlement upon `assetId`"},"assetAddress(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"assetAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetId:"the referenced asset"},returns:{_0:"the contract address of the vaulted asset"},notice:"the contract address of the vaulted asset"},"assetBalance(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"assetBalance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"returns the balance of the underlying ERC20 token"},"clearEntitlement(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"clearEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the id of the asset to clear"},notice:"Allows the entitled address to release their claim on the asset"},"clearEntitlementAndDistribute(uint32,address)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"receiver",type:"address"}],name:"clearEntitlementAndDistribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the Id of the asset to clear",receiver:"the intended receiver of the asset"},notice:"Removes the active entitlement from a vault and returns the asset to the beneficial owner"},"entitlementExpiration(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"entitlementExpiration",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",details:"returns the 0 if no entitlement is set",returns:{_0:"the block timestamp after which the entitlement expires"},notice:"Looks up the expiration timestamp of the current entitlement"},"getApprovedOperator(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getApprovedOperator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `assetId` must exist."},"getBeneficialOwner(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getBeneficialOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetId:"the referenced asset"},returns:{_0:"the address of the beneficial owner of the asset"},notice:"looks up the current beneficial owner of the asset"},"getCurrentEntitlementOperator(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getCurrentEntitlementOperator",outputs:[{internalType:"bool",name:"",type:"bool"},{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetId:"the id of the underlying asset"},notice:"looks up the current operator of an entitlement on an asset"},"getHoldsAsset(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getHoldsAsset",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{assetId:"the referenced asset"},returns:{_0:"true if the asset is currently within the vault, false otherwise"},notice:"checks if the asset is currently stored in the vault"},"grantEntitlement((address,address,address,uint32,uint32))":{inputs:[{components:[{internalType:"address",name:"beneficialOwner",type:"address"},{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"vaultAddress",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint32",name:"expiry",type:"uint32"}],internalType:"struct Entitlements.Entitlement",name:"entitlement",type:"tuple"}],name:"grantEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",details:"this function call is signed by the sender per the EVM, so we know the entitlement is authentic",params:{entitlement:"The entitlement to impose onto the contract"},notice:"Allows the beneficial owner to grant an entitlement to an asset within the contract"},"imposeEntitlement(address,uint32,uint32,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint32",name:"expiry",type:"uint32"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"imposeEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the id of the asset within the vault",expiry:"the duration of the entitlement",operator:"the operator to entitle",r:"sig r",s:"sig s",v:"sig v"},notice:"Add an entitlement claim to the asset held within the contract"},"setBeneficialOwner(uint32,address)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"newBeneficialOwner",type:"address"}],name:"setBeneficialOwner",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the id of the subject asset to impose the entitlement",newBeneficialOwner:"the account of the person who is able to withdrawal when there are no entitlements."},notice:"setBeneficialOwner updates the current address that can claim the asset when it is free of entitlements."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"withdrawalAsset(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"withdrawalAsset",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the asset to remove from the vault"},notice:"Withdrawal an unencumbered asset from this vault"}}},"src/interfaces/IHookERC721Vault.sol:IHookERC721Vault":{source:"src/interfaces/IHookERC721Vault.sol",name:"IHookERC721Vault",title:"Hook ERC-721 Vault interface",author:"Jake Nyquist-j@hook.xyz",details:"the IHookERC721 vault is an extension of the standard IHookVault specifically designed to hold and receive ERC721 Tokens. FLASH LOAN -     (1) beneficial owners are able to borrow the vaulted asset for a single function call     (2) to borrow the asset, they must implement and deploy a {IERC721FlashLoanReceiver}         contract, and then call the flashLoan method.     (3) At the end of the flashLoan, we ensure the asset is still owned by the vault.",events:{"Approval(address,address,uint32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficialOwner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint32",name:"assetId",type:"uint32"}],name:"Approval",type:"event",notice:"Emitted when `beneficialOwner` enables `approved` to manage the `assetId` asset."},"AssetFlashLoaned(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"address",name:"flashLoanImpl",type:"address"}],name:"AssetFlashLoaned",type:"event",details:"only one asset can be flash loaned at a time, and that asset is denoted by the tokenId emitted.",notice:"emitted after an asset is flash loaned by its beneficial owner."},"AssetReceived(address,address,address,uint32)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"address",name:"contractAddress",type:"address"},{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"}],name:"AssetReceived",type:"event",notice:"emitted when an asset is added into the vault"},"AssetWithdrawn(uint32,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"AssetWithdrawn",type:"event",notice:"emitted when an asset is withdrawn from the vault"},"BeneficialOwnerSet(uint32,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"},{indexed:!1,internalType:"address",name:"setBy",type:"address"}],name:"BeneficialOwnerSet",type:"event",notice:"emitted when the beneficial owner of an asset changes"},"EntitlementCleared(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"assetId",type:"uint256"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"EntitlementCleared",type:"event",notice:"emitted when an entitlement is cleared from an asset"},"EntitlementImposed(uint32,address,uint32,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"entitledAccount",type:"address"},{indexed:!1,internalType:"uint32",name:"expiry",type:"uint32"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"EntitlementImposed",type:"event",notice:"emitted when an entitlement is placed on an asset"}},methods:{"approveOperator(address,uint32)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"}],name:"approveOperator",outputs:[],stateMutability:"nonpayable",type:"function",details:"Only a single account can be approved at a time, so approving the zero address clears previous approvals.   * Requirements: -  The caller must be the beneficial owner - `tokenId` must exist. Emits an {Approval} event.",notice:"Gives permission to `to` to impose an entitlement upon `assetId`"},"assetAddress(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"assetAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetId:"the referenced asset"},returns:{_0:"the contract address of the vaulted asset"},notice:"the contract address of the vaulted asset"},"assetTokenId(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"assetTokenId",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"the tokenID of the underlying ERC721 token;"},"clearEntitlement(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"clearEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the id of the asset to clear"},notice:"Allows the entitled address to release their claim on the asset"},"clearEntitlementAndDistribute(uint32,address)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"receiver",type:"address"}],name:"clearEntitlementAndDistribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the Id of the asset to clear",receiver:"the intended receiver of the asset"},notice:"Removes the active entitlement from a vault and returns the asset to the beneficial owner"},"entitlementExpiration(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"entitlementExpiration",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",details:"returns the 0 if no entitlement is set",returns:{_0:"the block timestamp after which the entitlement expires"},notice:"Looks up the expiration timestamp of the current entitlement"},"flashLoan(uint32,address,bytes)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"receiverAddress",type:"address"},{internalType:"bytes",name:"params",type:"bytes"}],name:"flashLoan",outputs:[],stateMutability:"nonpayable",type:"function",details:"the flashloan receiver can perform arbitrary logic, but must approve the vault as an operator before returning.",params:{params:"calldata params to forward to the receiver",receiverAddress:"the contract which implements the {IERC721FlashLoanReceiver} interface to utilize the asset while it is loaned out"},notice:"flashLoans the vaulted asset to another contract for use and return to the vault. Only the owner may perform the flashloan"},"getApprovedOperator(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getApprovedOperator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `assetId` must exist."},"getBeneficialOwner(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getBeneficialOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetId:"the referenced asset"},returns:{_0:"the address of the beneficial owner of the asset"},notice:"looks up the current beneficial owner of the asset"},"getCurrentEntitlementOperator(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getCurrentEntitlementOperator",outputs:[{internalType:"bool",name:"",type:"bool"},{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetId:"the id of the underlying asset"},notice:"looks up the current operator of an entitlement on an asset"},"getHoldsAsset(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getHoldsAsset",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{assetId:"the referenced asset"},returns:{_0:"true if the asset is currently within the vault, false otherwise"},notice:"checks if the asset is currently stored in the vault"},"grantEntitlement((address,address,address,uint32,uint32))":{inputs:[{components:[{internalType:"address",name:"beneficialOwner",type:"address"},{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"vaultAddress",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint32",name:"expiry",type:"uint32"}],internalType:"struct Entitlements.Entitlement",name:"entitlement",type:"tuple"}],name:"grantEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",details:"this function call is signed by the sender per the EVM, so we know the entitlement is authentic",params:{entitlement:"The entitlement to impose onto the contract"},notice:"Allows the beneficial owner to grant an entitlement to an asset within the contract"},"imposeEntitlement(address,uint32,uint32,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint32",name:"expiry",type:"uint32"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"imposeEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the id of the asset within the vault",expiry:"the duration of the entitlement",operator:"the operator to entitle",r:"sig r",s:"sig s",v:"sig v"},notice:"Add an entitlement claim to the asset held within the contract"},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom} by `operator` from `from`, this function is called. It must return its Solidity selector to confirm the token transfer. If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted. The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`."},"setBeneficialOwner(uint32,address)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"newBeneficialOwner",type:"address"}],name:"setBeneficialOwner",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the id of the subject asset to impose the entitlement",newBeneficialOwner:"the account of the person who is able to withdrawal when there are no entitlements."},notice:"setBeneficialOwner updates the current address that can claim the asset when it is free of entitlements."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"withdrawalAsset(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"withdrawalAsset",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the asset to remove from the vault"},notice:"Withdrawal an unencumbered asset from this vault"}}},"src/interfaces/IHookERC721VaultFactory.sol:IHookERC721VaultFactory":{source:"src/interfaces/IHookERC721VaultFactory.sol",name:"IHookERC721VaultFactory",title:"HookERC721Factory-factory for instances of the hook vault",author:"Jake Nyquist-j@hook.xyz",notice:"The Factory creates a specific vault for ERC721s.",events:{"ERC721MultiVaultCreated(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"nftAddress",type:"address"},{indexed:!1,internalType:"address",name:"vaultAddress",type:"address"}],name:"ERC721MultiVaultCreated",type:"event",params:{nftAddress:"the address of the nft contract that may be deposited into the new vault",vaultAddress:"address of the newly deployed vault"},notice:"emitted when a new MultiVault is deployed by the protocol"},"ERC721VaultCreated(address,uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"nftAddress",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"address",name:"vaultAddress",type:"address"}],name:"ERC721VaultCreated",type:"event"}},methods:{"findOrCreateVault(address,uint256)":{inputs:[{internalType:"address",name:"nftAddress",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"findOrCreateVault",outputs:[{internalType:"contract IHookERC721Vault",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",params:{nftAddress:"the contract address for the ERC-721",tokenId:"the tokenId for the ERC-721"},notice:"creates a vault for a specific tokenId. If there is a multi-vault in existence which supports that address the address for that vault is returned as a new one does not need to be made."},"getMultiVault(address)":{inputs:[{internalType:"address",name:"nftAddress",type:"address"}],name:"getMultiVault",outputs:[{internalType:"contract IHookERC721Vault",name:"",type:"address"}],stateMutability:"view",type:"function",params:{nftAddress:"the contract address for the ERC-721"},returns:{_0:"the address of the {IERC721Vault} multi asset vault, or the null address if one does not exist"},notice:"gets the address of a multi-asset vault for a particular ERC-721 contract, if one exists"},"getVault(address,uint256)":{inputs:[{internalType:"address",name:"nftAddress",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getVault",outputs:[{internalType:"contract IHookERC721Vault",name:"",type:"address"}],stateMutability:"view",type:"function",params:{nftAddress:"the contract address for the ERC-721",tokenId:"the tokenId for the ERC-721"},returns:{_0:"the address of a {IERC721Vault} if one exists that supports the particular ERC-721, or the null address otherwise"},notice:"gets the address of a vault for a particular ERC-721 token"},"makeMultiVault(address)":{inputs:[{internalType:"address",name:"nftAddress",type:"address"}],name:"makeMultiVault",outputs:[{internalType:"contract IHookERC721Vault",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",params:{nftAddress:"the contract address for the ERC-721 to be supported by the vault"},returns:{_0:"the address of the newly deployed {IERC721Vault} multi asset vault"},notice:"deploy a multi-asset vault if one has not already been deployed"},"makeSoloVault(address,uint256)":{inputs:[{internalType:"address",name:"nftAddress",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"makeSoloVault",outputs:[{internalType:"contract IHookERC721Vault",name:"",type:"address"}],stateMutability:"nonpayable",type:"function",details:"the only valid asset id in this vault is = 0",params:{nftAddress:"the address of the underlying nft contract",tokenId:"the individual token that can be deposited into this vault"},notice:"make a new vault that can contain a single asset only"}}},"src/interfaces/IHookOption.sol:IHookOption":{source:"src/interfaces/IHookOption.sol",name:"IHookOption",methods:{"getExpiration(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getExpiration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getStrikePrice(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getStrikePrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"}}},"src/interfaces/IHookProtocol.sol:IHookProtocol":{source:"src/interfaces/IHookProtocol.sol",name:"IHookProtocol",title:"HookProtocol configuration and access control repository",author:"Jake Nyquist-j@hook.xyz",details:"it is critically important that the particular protocol implementation is correct as, if it is not, all assets contained within protocol contracts can be easily compromised.",events:{"RoleAdminChanged(bytes32,bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"previousAdminRole",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newAdminRole",type:"bytes32"}],name:"RoleAdminChanged",type:"event"},"RoleGranted(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleGranted",type:"event"},"RoleRevoked(bytes32,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!0,internalType:"address",name:"account",type:"address"},{indexed:!0,internalType:"address",name:"sender",type:"address"}],name:"RoleRevoked",type:"event"}},methods:{"coveredCallContract()":{inputs:[],name:"coveredCallContract",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"the address of the deployed CoveredCallFactory used by the protocol"},"getCollectionConfig(address,bytes32)":{inputs:[{internalType:"address",name:"collectionAddress",type:"address"},{internalType:"bytes32",name:"conf",type:"bytes32"}],name:"getCollectionConfig",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{collectionAddress:"the collection for which to lookup a configuration flag",conf:"the config identifier for the configuration flag"},returns:{_0:"the true or false value of the config"},notice:"get a configuration flag with a specific key for a collection"},"getRoleAdmin(bytes32)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"}],name:"getRoleAdmin",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}."},"getWETHAddress()":{inputs:[],name:"getWETHAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"these are values for popular chains: mainnet: 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 kovan: 0xd0a1e359811322d97991e03f863a0c30c2cf029c ropsten: 0xc778417e063141139fce010982780140aa0cd5ab rinkeby: 0xc778417e063141139fce010982780140aa0cd5ab",returns:{_0:"the weth address"},notice:"the standard weth address on this chain"},"grantRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"renounceRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `account`."},"revokeRole(bytes32,address)":{inputs:[{internalType:"bytes32",name:"role",type:"bytes32"},{internalType:"address",name:"account",type:"address"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",details:"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."},"throwWhenPaused()":{inputs:[],name:"throwWhenPaused",outputs:[],stateMutability:"nonpayable",type:"function",notice:"callable function that reverts when the protocol is paused"},"vaultContract()":{inputs:[],name:"vaultContract",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"the address of the deployed VaultFactory used by the protocol"}}},"src/interfaces/IHookVault.sol:IHookVault":{source:"src/interfaces/IHookVault.sol",name:"IHookVault",title:"Generic Hook Vault-a vault designed to contain a single asset to be used as escrow.",author:"Jake Nyquist-j@hook.xyz",notice:'The Vault holds an asset on behalf of the owner. The owner is able to post this asset as collateral to other protocols by signing a message, called an "entitlement", that gives a specific account the ability to change the owner. The vault can work with multiple assets via the assetId, where the asset or set of assets covered by each segment is granted an individual id. Every asset must be identified by an assetId to comply with this interface, even if the vault only contains one asset. ENTITLEMENTS -     (1) only one entitlement can be placed at a time.     (2) entitlements must expire, but can also be cleared by the entitled party     (3) if an entitlement expires, the current beneficial owner gains immediate sole control over the        asset     (4) the entitled entity can modify the beneficial owner of the asset, but cannot withdrawal.     (5) the beneficial owner cannot modify the beneficial owner while an entitlement is in place',events:{"Approval(address,address,uint32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"beneficialOwner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint32",name:"assetId",type:"uint32"}],name:"Approval",type:"event",notice:"Emitted when `beneficialOwner` enables `approved` to manage the `assetId` asset."},"AssetReceived(address,address,address,uint32)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"owner",type:"address"},{indexed:!1,internalType:"address",name:"sender",type:"address"},{indexed:!1,internalType:"address",name:"contractAddress",type:"address"},{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"}],name:"AssetReceived",type:"event",notice:"emitted when an asset is added into the vault"},"AssetWithdrawn(uint32,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"AssetWithdrawn",type:"event",notice:"emitted when an asset is withdrawn from the vault"},"BeneficialOwnerSet(uint32,address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"},{indexed:!1,internalType:"address",name:"setBy",type:"address"}],name:"BeneficialOwnerSet",type:"event",details:"it is not required that this event is emitted when an entitlement is imposed that also modifies the beneficial owner.",notice:"emitted when the beneficial owner of an asset changes"},"EntitlementCleared(uint256,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"assetId",type:"uint256"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"EntitlementCleared",type:"event",notice:"emitted when an entitlement is cleared from an asset"},"EntitlementImposed(uint32,address,uint32,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint32",name:"assetId",type:"uint32"},{indexed:!1,internalType:"address",name:"entitledAccount",type:"address"},{indexed:!1,internalType:"uint32",name:"expiry",type:"uint32"},{indexed:!1,internalType:"address",name:"beneficialOwner",type:"address"}],name:"EntitlementImposed",type:"event",notice:"emitted when an entitlement is placed on an asset"}},methods:{"approveOperator(address,uint32)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"}],name:"approveOperator",outputs:[],stateMutability:"nonpayable",type:"function",details:"Only a single account can be approved at a time, so approving the zero address clears previous approvals.   * Requirements: -  The caller must be the beneficial owner - `tokenId` must exist. Emits an {Approval} event.",notice:"Gives permission to `to` to impose an entitlement upon `assetId`"},"assetAddress(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"assetAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetId:"the referenced asset"},returns:{_0:"the contract address of the vaulted asset"},notice:"the contract address of the vaulted asset"},"clearEntitlement(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"clearEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the id of the asset to clear"},notice:"Allows the entitled address to release their claim on the asset"},"clearEntitlementAndDistribute(uint32,address)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"receiver",type:"address"}],name:"clearEntitlementAndDistribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the Id of the asset to clear",receiver:"the intended receiver of the asset"},notice:"Removes the active entitlement from a vault and returns the asset to the beneficial owner"},"entitlementExpiration(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"entitlementExpiration",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",details:"returns the 0 if no entitlement is set",returns:{_0:"the block timestamp after which the entitlement expires"},notice:"Looks up the expiration timestamp of the current entitlement"},"getApprovedOperator(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getApprovedOperator",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account approved for `tokenId` token. Requirements: - `assetId` must exist."},"getBeneficialOwner(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getBeneficialOwner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetId:"the referenced asset"},returns:{_0:"the address of the beneficial owner of the asset"},notice:"looks up the current beneficial owner of the asset"},"getCurrentEntitlementOperator(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getCurrentEntitlementOperator",outputs:[{internalType:"bool",name:"",type:"bool"},{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",params:{assetId:"the id of the underlying asset"},notice:"looks up the current operator of an entitlement on an asset"},"getHoldsAsset(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"getHoldsAsset",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{assetId:"the referenced asset"},returns:{_0:"true if the asset is currently within the vault, false otherwise"},notice:"checks if the asset is currently stored in the vault"},"grantEntitlement((address,address,address,uint32,uint32))":{inputs:[{components:[{internalType:"address",name:"beneficialOwner",type:"address"},{internalType:"address",name:"operator",type:"address"},{internalType:"address",name:"vaultAddress",type:"address"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint32",name:"expiry",type:"uint32"}],internalType:"struct Entitlements.Entitlement",name:"entitlement",type:"tuple"}],name:"grantEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",details:"this function call is signed by the sender per the EVM, so we know the entitlement is authentic",params:{entitlement:"The entitlement to impose onto the contract"},notice:"Allows the beneficial owner to grant an entitlement to an asset within the contract"},"imposeEntitlement(address,uint32,uint32,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"uint32",name:"expiry",type:"uint32"},{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"imposeEntitlement",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the id of the asset within the vault",expiry:"the duration of the entitlement",operator:"the operator to entitle",r:"sig r",s:"sig s",v:"sig v"},notice:"Add an entitlement claim to the asset held within the contract"},"setBeneficialOwner(uint32,address)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"},{internalType:"address",name:"newBeneficialOwner",type:"address"}],name:"setBeneficialOwner",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the id of the subject asset to impose the entitlement",newBeneficialOwner:"the account of the person who is able to withdrawal when there are no entitlements."},notice:"setBeneficialOwner updates the current address that can claim the asset when it is free of entitlements."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas."},"withdrawalAsset(uint32)":{inputs:[{internalType:"uint32",name:"assetId",type:"uint32"}],name:"withdrawalAsset",outputs:[],stateMutability:"nonpayable",type:"function",params:{assetId:"the asset to remove from the vault"},notice:"Withdrawal an unencumbered asset from this vault"}}},"src/interfaces/IInitializeableBeacon.sol:IInitializeableBeacon":{source:"src/interfaces/IInitializeableBeacon.sol",name:"IInitializeableBeacon",title:"Interface for a beacon with an initializer function",author:"Jake Nyquist-j@hook.xyz",details:"the Hook Beacons conform to this interface, and can be called with this initializer in order to start a beacon",methods:{"initializeBeacon(address,bytes)":{inputs:[{internalType:"address",name:"beacon",type:"address"},{internalType:"bytes",name:"data",type:"bytes"}],name:"initializeBeacon",outputs:[],stateMutability:"nonpayable",type:"function"}}},"src/interfaces/IWETH.sol:IWETH":{source:"src/interfaces/IWETH.sol",name:"IWETH",methods:{"deposit()":{inputs:[],name:"deposit",outputs:[],stateMutability:"payable",type:"function"},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"value",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function"},"withdraw(uint256)":{inputs:[{internalType:"uint256",name:"wad",type:"uint256"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function"}}},"src/interfaces/delegate-cash/IDelegationRegistry.sol:IDelegationRegistry":{source:"src/interfaces/delegate-cash/IDelegationRegistry.sol",name:"IDelegationRegistry",title:"An immutable registry contract to be deployed as a standalone primitive",details:"See EIP-5639, new project launches can read previous cold wallet -> hot wallet delegations from here and integrate those permissions into their flow",events:{"DelegateForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"vault",type:"address"},{indexed:!1,internalType:"address",name:"delegate",type:"address"},{indexed:!1,internalType:"bool",name:"value",type:"bool"}],name:"DelegateForAll",type:"event",notice:"Emitted when a user delegates their entire wallet"},"DelegateForContract(address,address,address,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"vault",type:"address"},{indexed:!1,internalType:"address",name:"delegate",type:"address"},{indexed:!1,internalType:"address",name:"contract_",type:"address"},{indexed:!1,internalType:"bool",name:"value",type:"bool"}],name:"DelegateForContract",type:"event",notice:"Emitted when a user delegates a specific contract"},"DelegateForToken(address,address,address,uint256,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"vault",type:"address"},{indexed:!1,internalType:"address",name:"delegate",type:"address"},{indexed:!1,internalType:"address",name:"contract_",type:"address"},{indexed:!1,internalType:"uint256",name:"tokenId",type:"uint256"},{indexed:!1,internalType:"bool",name:"value",type:"bool"}],name:"DelegateForToken",type:"event",notice:"Emitted when a user delegates a specific token"},"RevokeAllDelegates(address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"vault",type:"address"}],name:"RevokeAllDelegates",type:"event",notice:"Emitted when a user revokes all delegations"},"RevokeDelegate(address,address)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"vault",type:"address"},{indexed:!1,internalType:"address",name:"delegate",type:"address"}],name:"RevokeDelegate",type:"event",notice:"Emitted when a user revoes all delegations for a given delegate"}},methods:{"checkDelegateForAll(address,address)":{inputs:[{internalType:"address",name:"delegate",type:"address"},{internalType:"address",name:"vault",type:"address"}],name:"checkDelegateForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{delegate:"The hotwallet to act on your behalf",vault:"The cold wallet who issued the delegation"},notice:"Returns true if the address is delegated to act on the entire vault"},"checkDelegateForContract(address,address,address)":{inputs:[{internalType:"address",name:"delegate",type:"address"},{internalType:"address",name:"vault",type:"address"},{internalType:"address",name:"contract_",type:"address"}],name:"checkDelegateForContract",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{contract_:"The address for the contract you're delegating",delegate:"The hotwallet to act on your behalf",vault:"The cold wallet who issued the delegation"},notice:"Returns true if the address is delegated to act on your behalf for a token contract or an entire vault"},"checkDelegateForToken(address,address,address,uint256)":{inputs:[{internalType:"address",name:"delegate",type:"address"},{internalType:"address",name:"vault",type:"address"},{internalType:"address",name:"contract_",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"checkDelegateForToken",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{contract_:"The address for the contract you're delegating",delegate:"The hotwallet to act on your behalf",tokenId:"The token id for the token you're delegating",vault:"The cold wallet who issued the delegation"},notice:"Returns true if the address is delegated to act on your behalf for a specific token, the token's contract or an entire vault"},"delegateForAll(address,bool)":{inputs:[{internalType:"address",name:"delegate",type:"address"},{internalType:"bool",name:"value",type:"bool"}],name:"delegateForAll",outputs:[],stateMutability:"nonpayable",type:"function",params:{delegate:"The hotwallet to act on your behalf",value:"Whether to enable or disable delegation for this address, true for setting and false for revoking"},notice:"Allow the delegate to act on your behalf for all contracts"},"delegateForContract(address,address,bool)":{inputs:[{internalType:"address",name:"delegate",type:"address"},{internalType:"address",name:"contract_",type:"address"},{internalType:"bool",name:"value",type:"bool"}],name:"delegateForContract",outputs:[],stateMutability:"nonpayable",type:"function",params:{contract_:"The address for the contract you're delegating",delegate:"The hotwallet to act on your behalf",value:"Whether to enable or disable delegation for this address, true for setting and false for revoking"},notice:"Allow the delegate to act on your behalf for a specific contract"},"delegateForToken(address,address,uint256,bool)":{inputs:[{internalType:"address",name:"delegate",type:"address"},{internalType:"address",name:"contract_",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bool",name:"value",type:"bool"}],name:"delegateForToken",outputs:[],stateMutability:"nonpayable",type:"function",params:{contract_:"The address for the contract you're delegating",delegate:"The hotwallet to act on your behalf",tokenId:"The token id for the token you're delegating",value:"Whether to enable or disable delegation for this address, true for setting and false for revoking"},notice:"Allow the delegate to act on your behalf for a specific token"},"getContractLevelDelegations(address)":{inputs:[{internalType:"address",name:"vault",type:"address"}],name:"getContractLevelDelegations",outputs:[{components:[{internalType:"address",name:"contract_",type:"address"},{internalType:"address",name:"delegate",type:"address"}],internalType:"struct IDelegationRegistry.ContractDelegation[]",name:"delegations",type:"tuple[]"}],stateMutability:"view",type:"function",params:{vault:"The cold wallet who issued the delegations"},returns:{delegations:"Array of ContractDelegation structs"},notice:"Returns all contract-level delegations for a given vault"},"getDelegatesForAll(address)":{inputs:[{internalType:"address",name:"vault",type:"address"}],name:"getDelegatesForAll",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",params:{vault:"The cold wallet who issued the delegation"},returns:{_0:"addresses Array of wallet-level delegates for a given vault"},notice:"Returns an array of wallet-level delegates for a given vault"},"getDelegatesForContract(address,address)":{inputs:[{internalType:"address",name:"vault",type:"address"},{internalType:"address",name:"contract_",type:"address"}],name:"getDelegatesForContract",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",params:{contract_:"The address for the contract you're delegating",vault:"The cold wallet who issued the delegation"},returns:{_0:"addresses Array of contract-level delegates for a given vault and contract"},notice:"Returns an array of contract-level delegates for a given vault and contract"},"getDelegatesForToken(address,address,uint256)":{inputs:[{internalType:"address",name:"vault",type:"address"},{internalType:"address",name:"contract_",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getDelegatesForToken",outputs:[{internalType:"address[]",name:"",type:"address[]"}],stateMutability:"view",type:"function",params:{contract_:"The address for the contract holding the token",tokenId:"The token id for the token you're delegating",vault:"The cold wallet who issued the delegation"},returns:{_0:"addresses Array of contract-level delegates for a given vault's token"},notice:"Returns an array of contract-level delegates for a given vault's token"},"getDelegationsByDelegate(address)":{inputs:[{internalType:"address",name:"delegate",type:"address"}],name:"getDelegationsByDelegate",outputs:[{components:[{internalType:"enum IDelegationRegistry.DelegationType",name:"type_",type:"uint8"},{internalType:"address",name:"vault",type:"address"},{internalType:"address",name:"delegate",type:"address"},{internalType:"address",name:"contract_",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],internalType:"struct IDelegationRegistry.DelegationInfo[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",params:{delegate:"The delegate that you would like to retrieve delegations for"},returns:{_0:"info Array of DelegationInfo structs"},notice:"Returns all active delegations a given delegate is able to claim on behalf of"},"getTokenLevelDelegations(address)":{inputs:[{internalType:"address",name:"vault",type:"address"}],name:"getTokenLevelDelegations",outputs:[{components:[{internalType:"address",name:"contract_",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"address",name:"delegate",type:"address"}],internalType:"struct IDelegationRegistry.TokenDelegation[]",name:"delegations",type:"tuple[]"}],stateMutability:"view",type:"function",params:{vault:"The cold wallet who issued the delegations"},returns:{delegations:"Array of TokenDelegation structs"},notice:"Returns all token-level delegations for a given vault"},"revokeAllDelegates()":{inputs:[],name:"revokeAllDelegates",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Revoke all delegates"},"revokeDelegate(address)":{inputs:[{internalType:"address",name:"delegate",type:"address"}],name:"revokeDelegate",outputs:[],stateMutability:"nonpayable",type:"function",params:{delegate:"The hotwallet to revoke"},notice:"Revoke a specific delegate for all their permissions"},"revokeSelf(address)":{inputs:[{internalType:"address",name:"vault",type:"address"}],name:"revokeSelf",outputs:[],stateMutability:"nonpayable",type:"function",params:{vault:"The vault which delegated to the msg.sender, and should be removed"},notice:"Remove yourself as a delegate for a specific vault"}}},"src/interfaces/zeroex-v4/IPropertyValidator.sol:IPropertyValidator":{source:"src/interfaces/zeroex-v4/IPropertyValidator.sol",name:"IPropertyValidator",methods:{"validateProperty(address,uint256,bytes)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"propertyData",type:"bytes"}],name:"validateProperty",outputs:[],stateMutability:"view",type:"function",details:"Checks that the given ERC721/ERC1155 asset satisfies the properties encoded in `propertyData`.      Should revert if the asset does not satisfy the specified properties.",params:{propertyData:"Encoded properties or auxiliary data needed to perform the check.",tokenAddress:"The ERC721/ERC1155 token contract address.",tokenId:"The ERC721/ERC1155 tokenId of the asset to check."}}}},"src/lib/BeaconSalts.sol:BeaconSalts":{source:"src/lib/BeaconSalts.sol",name:"BeaconSalts"},"src/lib/Entitlements.sol:Entitlements":{source:"src/lib/Entitlements.sol",name:"Entitlements"},"src/lib/HookStrings.sol:HookStrings":{source:"src/lib/HookStrings.sol",name:"HookStrings"},"src/lib/PoolOrders.sol:PoolOrders":{source:"src/lib/PoolOrders.sol",name:"PoolOrders"},"src/lib/Signatures.sol:Signatures":{source:"src/lib/Signatures.sol",name:"Signatures",details:"A library for validating signatures from ZeroEx"},"src/lib/TokenURI.sol:TokenURI":{source:"src/lib/TokenURI.sol",name:"TokenURI",details:"This contract implements some ERC721 / for hook instruments.",methods:{"tokenURIERC721(uint256,address,uint256,uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"instrumentId",type:"uint256"},{internalType:"address",name:"underlyingAddress",type:"address"},{internalType:"uint256",name:"underlyingTokenId",type:"uint256"},{internalType:"uint256",name:"instrumentExpiration",type:"uint256"},{internalType:"uint256",name:"instrumentStrike",type:"uint256"},{internalType:"uint256",name:"transfers",type:"uint256"}],name:"tokenURIERC721",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"this is a basic tokenURI based on the loot contract for an ERC721"}}},"src/lib/lyra/BlackScholes.sol:BlackScholes":{source:"src/lib/lyra/BlackScholes.sol",name:"BlackScholes",title:"BlackScholes",author:"Lyra",details:"Contract to compute the black scholes price of options. Where the unit is unspecified, it should be treated as a PRECISE_DECIMAL, which has 1e27 units of precision. The default decimal matches the ethereum standard of 1e18 units of precision.",methods:{"_stdNormalCDF(int256)":{inputs:[{internalType:"int256",name:"x",type:"int256"}],name:"_stdNormalCDF",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",details:"The standard normal cumulative distribution of the value. borrowed from a C++ implementation https://stackoverflow.com/a/23119456"},"delta((uint256,uint256,uint256,uint256,int256))":{inputs:[{components:[{internalType:"uint256",name:"timeToExpirySec",type:"uint256"},{internalType:"uint256",name:"volatilityDecimal",type:"uint256"},{internalType:"uint256",name:"spotDecimal",type:"uint256"},{internalType:"uint256",name:"strikePriceDecimal",type:"uint256"},{internalType:"int256",name:"rateDecimal",type:"int256"}],internalType:"struct BlackScholes.BlackScholesInputs",name:"bsInput",type:"tuple"}],name:"delta",outputs:[{internalType:"int256",name:"callDeltaDecimal",type:"int256"},{internalType:"int256",name:"putDeltaDecimal",type:"int256"}],stateMutability:"pure",type:"function"},"optionPrices((uint256,uint256,uint256,uint256,int256))":{inputs:[{components:[{internalType:"uint256",name:"timeToExpirySec",type:"uint256"},{internalType:"uint256",name:"volatilityDecimal",type:"uint256"},{internalType:"uint256",name:"spotDecimal",type:"uint256"},{internalType:"uint256",name:"strikePriceDecimal",type:"uint256"},{internalType:"int256",name:"rateDecimal",type:"int256"}],internalType:"struct BlackScholes.BlackScholesInputs",name:"bsInput",type:"tuple"}],name:"optionPrices",outputs:[{internalType:"uint256",name:"call",type:"uint256"},{internalType:"uint256",name:"put",type:"uint256"}],stateMutability:"pure",type:"function"},"pricesDeltaStdVega((uint256,uint256,uint256,uint256,int256))":{inputs:[{components:[{internalType:"uint256",name:"timeToExpirySec",type:"uint256"},{internalType:"uint256",name:"volatilityDecimal",type:"uint256"},{internalType:"uint256",name:"spotDecimal",type:"uint256"},{internalType:"uint256",name:"strikePriceDecimal",type:"uint256"},{internalType:"int256",name:"rateDecimal",type:"int256"}],internalType:"struct BlackScholes.BlackScholesInputs",name:"bsInput",type:"tuple"}],name:"pricesDeltaStdVega",outputs:[{components:[{internalType:"uint256",name:"callPrice",type:"uint256"},{internalType:"uint256",name:"putPrice",type:"uint256"},{internalType:"int256",name:"callDelta",type:"int256"},{internalType:"int256",name:"putDelta",type:"int256"},{internalType:"uint256",name:"vega",type:"uint256"},{internalType:"uint256",name:"stdVega",type:"uint256"}],internalType:"struct BlackScholes.PricesDeltaStdVega",name:"",type:"tuple"}],stateMutability:"pure",type:"function"},"vega((uint256,uint256,uint256,uint256,int256))":{inputs:[{components:[{internalType:"uint256",name:"timeToExpirySec",type:"uint256"},{internalType:"uint256",name:"volatilityDecimal",type:"uint256"},{internalType:"uint256",name:"spotDecimal",type:"uint256"},{internalType:"uint256",name:"strikePriceDecimal",type:"uint256"},{internalType:"int256",name:"rateDecimal",type:"int256"}],internalType:"struct BlackScholes.BlackScholesInputs",name:"bsInput",type:"tuple"}],name:"vega",outputs:[{internalType:"uint256",name:"vegaDecimal",type:"uint256"}],stateMutability:"pure",type:"function"}}},"src/lib/lyra/FixedPointMathLib.sol:FixedPointMathLib":{source:"src/lib/lyra/FixedPointMathLib.sol",name:"FixedPointMathLib"},"src/lib/lyra/Math.sol:Math":{source:"src/lib/lyra/Math.sol",name:"Math",title:"Math",author:"Lyra",details:"Library to unify logic for common shared functions"},"src/lib/synthetix/DecimalMath.sol:DecimalMath":{source:"src/lib/synthetix/DecimalMath.sol",name:"DecimalMath",title:"DecimalMath",author:"Lyra",details:"Modified synthetix SafeDecimalMath to include internal arithmetic underflow/overflow.https://docs.synthetix.io/contracts/source/libraries/SafeDecimalMath/",methods:{"PRECISE_UNIT()":{inputs:[],name:"PRECISE_UNIT",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"UNIT()":{inputs:[],name:"UNIT",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"highPrecisionDecimals()":{inputs:[],name:"highPrecisionDecimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"preciseUnit()":{inputs:[],name:"preciseUnit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",returns:{_0:"Provides an interface to PRECISE_UNIT."}},"unit()":{inputs:[],name:"unit",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",returns:{_0:"Provides an interface to UNIT."}}}},"src/lib/synthetix/SignedDecimalMath.sol:SignedDecimalMath":{source:"src/lib/synthetix/SignedDecimalMath.sol",name:"SignedDecimalMath",title:"SignedDecimalMath",author:"Lyra",details:"Modified synthetix SafeSignedDecimalMath to include internal arithmetic underflow/overflow.https://docs.synthetix.io/contracts/source/libraries/safedecimalmath",methods:{"PRECISE_UNIT()":{inputs:[],name:"PRECISE_UNIT",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"UNIT()":{inputs:[],name:"UNIT",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"view",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"highPrecisionDecimals()":{inputs:[],name:"highPrecisionDecimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"preciseUnit()":{inputs:[],name:"preciseUnit",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"pure",type:"function",returns:{_0:"Provides an interface to PRECISE_UNIT."}},"unit()":{inputs:[],name:"unit",outputs:[{internalType:"int256",name:"",type:"int256"}],stateMutability:"pure",type:"function",returns:{_0:"Provides an interface to UNIT."}}}},"src/mixin/EIP712.sol:EIP712":{source:"src/mixin/EIP712.sol",name:"EIP712",details:"EIP712 helpers for features.",stateVariables:{"EIP712_DOMAIN_SEPARATOR()":{inputs:[],name:"EIP712_DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"stateVariable",details:"The domain hash separator for the entire call option protocol"}}},"src/mixin/HookInstrumentERC721.sol:HookInstrumentERC721":{source:"src/mixin/HookInstrumentERC721.sol",name:"HookInstrumentERC721",details:"This contract implements some ERC721 / for hook instruments.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"approved",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Approval",type:"event"},"ApprovalForAll(address,address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"operator",type:"address"},{indexed:!1,internalType:"bool",name:"approved",type:"bool"}],name:"ApprovalForAll",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!0,internalType:"uint256",name:"tokenId",type:"uint256"}],name:"Transfer",type:"event"}},stateVariables:{"_preApprovedMarketplace()":{inputs:[],name:"_preApprovedMarketplace",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"stateVariable",details:"the contact address for a marketplace to pre-approve"}},methods:{"approve(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"approve",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-approve}."},"balanceOf(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC721-balanceOf}."},"burn(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function",details:"Burns `tokenId`. See {ERC721-_burn}. Requirements: - The caller must own `tokenId` or be an approved operator."},"contractUri(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"contractUri",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"this is the OpenSea compatible collection - level metadata URI."},"getApproved(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"getApproved",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-getApproved}."},"getAssetId(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getAssetId",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",notice:"getter for the assetId of the underlying asset within a vault"},"getExpiration(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getExpiration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"getter for the options expiration. After this time the option is invalid"},"getStrikePrice(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getStrikePrice",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"getter for the option strike price"},"getTransferCount(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getTransferCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"this count can be used by overbooks to invalidate orders after a token has been transferred, preventing stale order execution by malicious parties",notice:"the number of times the token has been transferred"},"getVaultAddress(uint256)":{inputs:[{internalType:"uint256",name:"optionId",type:"uint256"}],name:"getVaultAddress",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",notice:"getter for the address holding the underlying asset"},"isApprovedForAll(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"operator",type:"address"}],name:"isApprovedForAll",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC721-isApprovedForAll}. this extension ensures that any operator contract located at {_approvedMarketpace} is considered approved internally in the ERC721 contract"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-name}."},"ownerOf(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"ownerOf",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"See {IERC721-ownerOf}."},"safeTransferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"safeTransferFrom(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"},{internalType:"bytes",name:"_data",type:"bytes"}],name:"safeTransferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-safeTransferFrom}."},"setApprovalForAll(address,bool)":{inputs:[{internalType:"address",name:"operator",type:"address"},{internalType:"bool",name:"approved",type:"bool"}],name:"setApprovalForAll",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-setApprovalForAll}."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721Metadata-symbol}."},"tokenURI(uint256)":{inputs:[{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"tokenURI",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IERC721-tokenURI}."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"tokenId",type:"uint256"}],name:"transferFrom",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC721-transferFrom}."}}},"src/mixin/PermissionConstants.sol:PermissionConstants":{source:"src/mixin/PermissionConstants.sol",name:"PermissionConstants",details:"new roles here should be initialized in the constructor of the protocol",notice:"roles on the hook protocol that can be read by other contract",methods:{"ALLOWLISTER_ROLE()":{inputs:[],name:"ALLOWLISTER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the allowlister is able to enable and disable projects to mint instruments"},"CALL_UPGRADER()":{inputs:[],name:"CALL_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the call upgrader role is able to upgrade the implementation of the covered call options"},"COLLECTION_CONF()":{inputs:[],name:"COLLECTION_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the collection configuration role allows the actor to make changes the collection configs on the protocol contract"},"MARKET_CONF()":{inputs:[],name:"MARKET_CONF",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the market configuration role allows the actor to make changes to how the market operates"},"PAUSER_ROLE()":{inputs:[],name:"PAUSER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the pauser is able to start and pause various components of the protocol"},"VAULT_UPGRADER()":{inputs:[],name:"VAULT_UPGRADER",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",notice:"the vault upgrader role is able to upgrade the implementation for all vaults"}}}};new wo({el:"#app",router:new ud({routes:[{path:"/",component:Dd,props:()=>({json:Vd})},{path:"*",component:Sd,props:e=>({json:Vd[e.path.slice(1)]})}]}),mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(md)})})()})();